#!/usr/bin/env python3

"""ROS wrapper to run DQN for snake controller.
License:
  BSD 3-Clause License
  Copyright (c) 2021, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
  1. Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
  3. Neither the name of the copyright holder nor the names of its
     contributors may be used to endorse or promote products derived from
     this software without specific prior written permission.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

# package
from snakedqn import Agent

# ROS
import rospy
from geometry_msgs.msg import Twist, PoseArray, PointStamped
from std_msgs.msg import Int32, Bool, String
from rosgraph_msgs.msg import Clock
from std_srvs.srv import Empty

# System
import time
import numpy as np
import sys
from transformations import euler_from_quaternion
from enum import IntEnum, unique

@unique
class Actions(IntEnum):
    """Possible actions for deep learner."""
    FORWARD = 0
    LEFT    = auto()
    RIGHT   = auto()
    SIZE    = auto()

class SnakeDQN(object):
    """ROS wrapper for the snake game DQN."""
    def __init__(self):
        rospy.init_node('snake_dqn')

        # Constants
        self.ANGULAR_VELOCITY = rospy.get_param('~angular_velocity', 2.0)
        self.LINEAR_VELOCITY = rospy.get_param('~linear_velocity', 2.0)
        self.NUM_SEGMENTS = rospy.get_param('~num_segments', 7)
        self.TIME_REWARD = rospy.get_param('~reward/per_second', -1.0)
        self.DEATH_REWARD = rospy.get_param('~reward/death', -50.0)
        self.GOAL_REWARD = rospy.get_param('~reward/goal', 10.0)

        # Publishers
        self.action_pub = rospy.Publisher('snake/cmd_vel', Twist, queue_size=1)

        # Subscribers
        rospy.Subscriber('snake/pose', PoseArray, self.pose_cb)
        rospy.Subscriber('snake/goal', PointStamped, self.goal_cb)
        rospy.Subscriber('snake/score', Int32, self.score_cb)
        rospy.Subscriber('snake/active', Bool, self.alive_cb)

        # Services
        # TODO make a service (requires custom messages)
        rospy.Service('snake/dqn/load_weights', String, self.load_cb)
        rospy.Service('snake/dqn/save_weights', String, self.save_cb)

        # State variables
        self.pose = None
        self.goal = None
        self.score = None
        self.alive = None

        self.prev_score = None
        self.prev_time = None

        # DQN Agent
        self.agent = Agent(3 + 2*self.NUM_SEGMENTS, Actions.SIZE)

    def spin_once(self):
        """Simple wait to allow other threads to handle callbacks."""
        if rospy.is_shutdown():
            raise rospy.ROSInterruptException()
        else:
            time.sleep(0.001)

    def get_action_msg(self, action):
        """Take the raw action from the deep learner and turn into message."""
        assert action >= 0 and action < Actions.SIZE

        action_msg = Twist()
        action_msg.linear.x = self.LINEAR_VELOCITY
        if action == Actions.LEFT:
            action_msg.angular.z = self.ANGULAR_VELOCITY
        if action == Actions.RIGHT:
            action_msg.angular.z = -self.ANGULAR_VELOCITY
        return action_msg

    def has_state(self):
        """Check if all required data is available to form state."""
        return (
            self.pose is not None and
            self.goal is not None and
            self.score is not None and
            self.alive is not None)

    def clear_state(self):
        """Clear state variables to wait for next callbacks."""
        self.pose = None
        self.goal = None
        self.score = None
        self.alive = None
        assert not self.has_state()

    def get_env(self, time):
        """Format the environment state to pass to the deep learning algorithm."""
        assert self.has_state()

        # format pose and goal into state column vector
        pose = np.asarray(self.pose, dtype=np.float32)
        goal = np.asarray(self.goal, dtype=np.float32)
        state = np.concatenate((pose, goal))

        # Determine reward and if done
        reward = 0
        done = False

        if self.last_score is not None:
            reward += self.GOAL_REWARD * (self.score - self.prev_score)
        self.last_score = self.score

        if self.prev_time is not None:
            reward += self.TIME_REWARD * (time - self.prev_time).to_sec()
        self.prev_time = time

        if not self.alive:
            reward += self.DEATH_REWARD
            done = True

        # match Gym's env.step() API
        return (state, reward, done, {})

    def reset(self):
        """reset for new episode."""
        self.clear_state()
        self.prev_score = None
        self.prev_time = None

    def pose_cb(self, pose_msg):
        """Callback for poses of each segment of snake."""
        if len(pose_msg.poses) != self.NUM_SEGMENTS:
            rospy.logerr("Bad pose callback")
            return

        yaw, __, __ = euler_from_quaternion((
            pose_msg.poses[0].orientation.x,
            pose_msg.poses[0].orientation.y,
            pose_msg.poses[0].orientation.z,
            pose_msg.poses[0].orientation.w))

        self.pose = tuple(
            [yaw] +
            [func(pose_msg.poses[i]) for i in range(self.NUM_SEGMENTS)
                for func in (
                    lambda pose: pose.position.x,
                    lambda pose: pose.position.y)])

    def goal_cb(self, goal_msg):
        """Callback for location of goal."""
        self.goal = (goal_msg.point.x, goal_msg.point.y)

    def score_cb(self, score_msg):
        """Callback for score of game."""
        self.score = score_msg.data

    def alive_cb(self, alive_msg):
        """Callback for active state of snake."""
        self.alive = alive_msg.data

    def load_cb(self, load_msg):
        """Callback to load model weights."""
        self.agent.load(load_msg.data)

    def save_cb(self, save_msg):
        """Callback to save model weights."""
        self.agent.save(save_msg.data)

class Trainer(SnakeDQN):
    """Class for training the agent."""
    def __init__(self):
        super().__init__()

        self.DEATH_PENALTY    = rospy.get_param('~death_penalty', 50)
        self.GOAL_REWARD      = rospy.get_param('~goal_reward', 10)

        # Services
        self.reset_srv = rospy.ServiceProxy('snake/reset', Empty)

                # Tracking variables
        self.prev_score = None

         self.time = rospy.Time.from_sec(time.time())
            self.DELTA_T = rospy.Duration.from_sec(1.0 / rospy.get_param('~rate', 30.0))
            self.clock_pub = rospy.Publisher('/clock', Clock, queue_size=1)

            # Main loop
        try:
            # wait for snake to initialize
            while(not self.has_state()):
                # kickstart sim time
                self.time += self.DELTA_T
                self.clock_pub.publish(self.time)
                self.spin_once()

            # initialize variables
            self._reset()

            # begin agent's training routine
            self.agent.train(self.step, self.reset)
        except rospy.ROSInterruptException:
            pass

    def step(self, action):
        """Step simulation one time step and return new state."""
        assert self.TRAINING

        # Publish action
        self.action_pub.publish(self.get_action_msg(action))

        # Advance sim time
        self.time += self.DELTA_T
        self.clock_pub.publish(self.time)

        # Wait for sim process actions
        spins = 0
        while(not self.has_state()):
            self.spin_once()
            spins += 1

            if spins > 15:
                rospy.logwarn("Too many spins, advancing time")
                self.time += self.DELTA_T
                self.clock_pub.publish(self.time)

        # return state
        return self.get_state()

        self.reset_srv.call()
        return self.step(None)

class Evaluator(SnakeDQN):
    """Class for running the agent live."""
    def __init__(self):
        super().__init__()

        try:
            # initialize to wall time
            self.time = rospy.Time.now()

            # initialize variables
            self._reset()

            # begin reaction routine
            while not rospy.is_shutdown():
                self.loop_once()
        except rospy.ROSInterruptException:
            pass


    def loop_once(self):
        """Handle one step of inference."""
        assert not self.TRAINING

        # Wait for state
        while(not self.has_state()):
            self.spin_once()

        # update state
        self.time = rospy.Time.now()
        state, __, done, __ = self.get_state()

        # check for end of game
        if not done:
            self.action_pub.publish(
                self.get_action_msg(
                    self.agent.get_action(
                        self.agent.tranform_state(state))))

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--training":
        print("Starting DQN node for training")
        Trainer()
    else:
        print("Starting DQN node for evaluation")
        Evaluator()
