#!/usr/bin/env python3

"""ROS wrapper to run DQN for snake controller.
License:
  BSD 3-Clause License
  Copyright (c) 2021, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
  1. Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
  3. Neither the name of the copyright holder nor the names of its
     contributors may be used to endorse or promote products derived from
     this software without specific prior written permission.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

# package
from snakedqn import Agent

# ROS
import rospy
from geometry_msgs.msg import Twist, PoseArray, PointStamped
from std_msgs.msg import Int32, Bool, String
from rosgraph_msgs.msg import Clock
from std_srvs.srv import Empty, EmptyResponse
from diagnostic_msgs.msg import DiagnosticStatus, KeyValue

# System
import time, sys
import numpy as np
from transformations import euler_from_quaternion
from enum import IntEnum, unique, auto
from threading import Lock

@unique
class Actions(IntEnum):
    """Possible actions for deep learner."""
    FORWARD = 0
    LEFT = auto()
    RIGHT = auto()
    SIZE = auto()

class SnakeDQN(object):
    """ROS wrapper for the snake game DQN."""
    def __init__(self):
        rospy.init_node('snake_dqn')

        # Constants
        self.ANGULAR_VELOCITY = rospy.get_param('~angular_velocity', 2.0)
        self.LINEAR_VELOCITY = rospy.get_param('~linear_velocity', 2.0)
        self.NUM_SEGMENTS = rospy.get_param('~num_segments', 7)
        self.TIME_REWARD = rospy.get_param('~reward/per_second', -1.0)
        self.DEATH_REWARD = rospy.get_param('~reward/death', -50.0)
        self.GOAL_REWARD = rospy.get_param('~reward/goal', 10.0)

        # Publishers
        self.action_pub = rospy.Publisher('snake/cmd_vel', Twist, queue_size=1)

        # Subscribers
        rospy.Subscriber('snake/pose', PoseArray, self.pose_cb)
        rospy.Subscriber('snake/goal', PointStamped, self.goal_cb)
        rospy.Subscriber('snake/score', Int32, self.score_cb)
        rospy.Subscriber('snake/active', Bool, self.alive_cb)

        # Services
        # TODO make a service (requires custom messages)
        rospy.Subscriber('snake/dqn/load_weights', String, self.load_cb)
        rospy.Subscriber('snake/dqn/save_weights', String, self.save_cb)

        # State variables
        self.pose = None
        self.goal = None
        self.score = None
        self.alive = None

        self.prev_score = None
        self.prev_time = None

        # DQN Agent
        self.agent = Agent(3 + 2*self.NUM_SEGMENTS, Actions.SIZE)

    def spin_once(self):
        """Simple wait to allow other threads to handle callbacks."""
        if rospy.is_shutdown():
            raise rospy.ROSInterruptException()
        else:
            time.sleep(0.001)

    def get_action_msg(self, action):
        """Take the raw action from the deep learner and turn into message."""
        assert action >= 0 and action < Actions.SIZE

        action_msg = Twist()
        action_msg.linear.x = self.LINEAR_VELOCITY
        if action == Actions.LEFT:
            action_msg.angular.z = self.ANGULAR_VELOCITY
        if action == Actions.RIGHT:
            action_msg.angular.z = -self.ANGULAR_VELOCITY
        return action_msg

    def has_state(self):
        """Check if all required data is available to form state."""
        return (
            self.pose is not None and
            self.goal is not None and
            self.score is not None and
            self.alive is not None)

    def clear_state(self):
        """Clear state variables to wait for next callbacks."""
        self.pose = None
        self.goal = None
        self.score = None
        self.alive = None
        assert not self.has_state()

    def get_env(self, time):
        """Format the environment state to pass to the deep learning algorithm."""
        assert self.has_state()

        # format pose and goal into state column vector
        pose = np.asarray(self.pose, dtype=np.float32)
        goal = np.asarray(self.goal, dtype=np.float32)
        state = np.concatenate((pose, goal))

        # Determine reward and if done
        reward = 0
        done = False

        if self.prev_score is not None:
            reward += self.GOAL_REWARD * (self.score - self.prev_score)
        self.prev_score = self.score

        if self.prev_time is not None:
            reward += self.TIME_REWARD * (time - self.prev_time).to_sec()
        self.prev_time = time

        if not self.alive:
            reward += self.DEATH_REWARD
            done = True

        # match Gym's env.step() API
        return (state, reward, done, {})

    def reset(self):
        """reset for new episode."""
        self.clear_state()
        self.prev_score = None
        self.prev_time = None

    def pose_cb(self, pose_msg):
        """Callback for poses of each segment of snake."""
        if len(pose_msg.poses) != self.NUM_SEGMENTS:
            rospy.logerr("Bad pose callback")
            return

        yaw, __, __ = euler_from_quaternion((
            pose_msg.poses[0].orientation.x,
            pose_msg.poses[0].orientation.y,
            pose_msg.poses[0].orientation.z,
            pose_msg.poses[0].orientation.w))

        self.pose = tuple(
            [yaw] +
            [func(pose_msg.poses[i]) for i in range(self.NUM_SEGMENTS)
                for func in (
                    lambda pose: pose.position.x,
                    lambda pose: pose.position.y)])

    def goal_cb(self, goal_msg):
        """Callback for location of goal."""
        self.goal = (goal_msg.point.x, goal_msg.point.y)

    def score_cb(self, score_msg):
        """Callback for score of game."""
        self.score = score_msg.data

    def alive_cb(self, alive_msg):
        """Callback for active state of snake."""
        self.alive = alive_msg.data

    def load_cb(self, load_msg):
        """Callback to load model weights."""
        self.agent.load(load_msg.data)

    def save_cb(self, save_msg):
        """Callback to save model weights."""
        self.agent.save(save_msg.data)

class Trainer(SnakeDQN):
    """Class for training the agent."""
    def __init__(self):
        super().__init__()

        # Constants
        self.DELTA_T = rospy.Duration.from_sec(1.0 / rospy.get_param('~rate', 60.0))

        # Publishers
        self.clock_pub = rospy.Publisher('/clock', Clock, queue_size=1)
        self.log_pub = rospy.Publisher('snake/dqn/training', DiagnosticStatus, queue_size=1)

        # Services
        self.reset_srv = rospy.ServiceProxy('snake/reset', Empty)

        self.time = rospy.Time.from_sec(time.time())

        # Main loop
        try:
            # wait for snake to initialize
            rospy.loginfo("Waiting for snake to initialize.")
            while(not self.has_state()):
                # kickstart sim time
                self.time += self.DELTA_T
                self.clock_pub.publish(self.time)
                self.spin_once()
            rospy.loginfo("Done.")

            # initialize variables
            self.reset()

            # begin agent's training routine
            self.agent.train(self.step, self.reset_env, self.log)
        except rospy.ROSInterruptException:
            pass

    def step(self, action):
        """Step simulation one time step and return new state."""
        # Publish action
        self.clear_state()
        self.action_pub.publish(self.get_action_msg(action))

        # Advance time and wait for sim
        while(not self.has_state()):
            self.time += self.DELTA_T
            self.clock_pub.publish(self.time)
            self.spin_once()

        # return state
        return self.get_env(self.time)

    def reset_env(self):
        """Reset the environment for new episode."""
        self.reset_srv.call()
        self.reset()

        rospy.loginfo("Waiting for snake to re-initialize.")
        while(not self.has_state()):
            # kickstart sim time
            self.time += self.DELTA_T
            self.clock_pub.publish(self.time)
            self.spin_once()
        rospy.loginfo("Done.")

        # return initial state
        return self.get_env(self.time)

    def log(self, episode, net_reward, steps, epsilon):
        """Log training metrics."""
        log_msg = DiagnosticStatus()
        log_msg.name = "DQN training"
        log_msg.values.append(KeyValue(key="episode", value=f"{episode}"))
        log_msg.values.append(KeyValue(key="net_reward", value=f"{net_reward}"))
        log_msg.values.append(KeyValue(key="steps", value=f"{steps}"))
        log_msg.values.append(KeyValue(key="epsilon", value=f"{epsilon}"))
        self.log_pub.publish(log_msg)

class Evaluator(SnakeDQN):
    """Class for running the agent live."""
    def __init__(self):
        super().__init__()

        # Services
        self.reset_srv = rospy.Service('snake_dqn/reset', Empty, self.reset_cb)

        self.lock = Lock()

        try:
            # initialize variables
            self.reset()

            while not rospy.is_shutdown():
                self.lock.acquire()

                # Wait for state
                while(not self.has_state()):
                    self.spin_once()

                # update state
                state, __, done, __ = self.get_env(rospy.Time.now())

                # check for end of game and react
                if not done:
                    self.clear_state()
                    self.action_pub.publish(
                        self.get_action_msg(
                            self.agent.get_action(
                                self.agent.transform_state(state))))
                self.lock.release()

        except rospy.ROSInterruptException:
            pass

    def reset_cb(self, reset_srv):
        """Thread safe reset."""
        self.lock.acquire()
        self.reset()
        self.lock.release()
        return EmptyResponse()

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--training":
        print("Starting DQN node for training")
        Trainer()
    else:
        print("Starting DQN node for evaluation")
        Evaluator()
