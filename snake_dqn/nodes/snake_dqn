#!/usr/bin/env python3

"""ROS wrapper to run DQN for snake controller.
License:
  BSD 3-Clause License
  Copyright (c) 2021, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
  1. Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
  3. Neither the name of the copyright holder nor the names of its
     contributors may be used to endorse or promote products derived from
     this software without specific prior written permission.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

# package
from snakedqn import Agent

# ROS
import rospy
from geometry_msgs.msg import Twist, PoseArray, PointStamped
from std_msgs.msg import Int32, Bool, String
from rosgraph_msgs.msg import Clock
from std_srvs.srv import Empty, EmptyResponse
from diagnostic_msgs.msg import DiagnosticStatus, KeyValue

# System
import time, sys
import numpy as np
from transformations import euler_from_quaternion
from enum import IntEnum, unique, auto
from threading import Lock, Condition
from math import exp

@unique
class Actions(IntEnum):
    """Possible actions for deep learner."""
    FORWARD = 0
    LEFT = auto()
    RIGHT = auto()
    SIZE = auto()

class SnakeDQN(object):
    """ROS wrapper for the snake game DQN."""
    def __init__(self):
        rospy.init_node('snake_dqn')

        # Constants
        self.ANGULAR_VELOCITY = rospy.get_param('~angular_velocity', 2.0)
        self.LINEAR_VELOCITY = rospy.get_param('~linear_velocity', 2.0)
        self.NUM_SEGMENTS = rospy.get_param('~num_segments', 7)
        self.DEATH_REWARD = rospy.get_param('~reward/death', -100.0)
        self.GOAL_REWARD = rospy.get_param('~reward/goal', 50.0)
        self.BASE_REWARD = rospy.get_param('~reward/distance/base', 0.0)
        self.EXP_REWARD = rospy.get_param('~reward/distance/exp', 0.0)

        # Publishers
        self.action_pub = rospy.Publisher('snake/cmd_vel', Twist, queue_size=1)

        # State variables
        self.pose = None
        self.goal = None
        self.score = None
        self.alive = None

        self.prev_score = None
        self.prev_time = None

        self.cond = Condition()

        # DQN Agent
        self.agent = Agent(3 + 2*self.NUM_SEGMENTS, Actions.SIZE,
            memory_len=rospy.get_param('~dqn/memory_len', 2000),
            gamma=rospy.get_param('~dqn/gamma', 0.9),
            epsilon_max=rospy.get_param('~dqn/epsilon/max', 1.0),
            epsilon_min=rospy.get_param('~dqn/epsilon/min', 0.01),
            epsilon_steps=rospy.get_param('~dqn/epsilon/steps', 30000),
            learning_rate=rospy.get_param('~dqn/learning_rate', 0.01),
            batch_size=rospy.get_param('~dqn/batch_size', 64))

        # Subscribers
        rospy.Subscriber('snake/pose', PoseArray, self.pose_cb)
        rospy.Subscriber('snake/goal', PointStamped, self.goal_cb)
        rospy.Subscriber('snake/score', Int32, self.score_cb)
        rospy.Subscriber('snake/active', Bool, self.alive_cb)

        # Services
        # TODO make a service (requires custom messages)
        rospy.Subscriber('snake/dqn/load_weights', String, self.load_cb)
        rospy.Subscriber('snake/dqn/save_weights', String, self.save_cb)

    def wait_for_state(self):
        """Allow other threads to handle callbacks."""
        with self.cond:
            ret = self.cond.wait_for(self.has_state, 0.3)
        if rospy.is_shutdown():
            raise rospy.ROSInterruptException()
        else:
            return ret

    def get_action_msg(self, action):
        """Take the raw action from the deep learner and turn into message."""
        assert action >= 0 and action < Actions.SIZE

        action_msg = Twist()
        action_msg.linear.x = self.LINEAR_VELOCITY
        if action == Actions.LEFT:
            action_msg.angular.z = self.ANGULAR_VELOCITY
        if action == Actions.RIGHT:
            action_msg.angular.z = -self.ANGULAR_VELOCITY
        return action_msg

    def has_state(self):
        """Check if all required data is available to form state."""
        return (
            self.pose is not None and
            self.goal is not None and
            self.score is not None and
            self.alive is not None)

    def clear_state(self):
        """Clear state variables to wait for next callbacks."""
        self.pose = None
        self.goal = None
        self.score = None
        self.alive = None
        assert not self.has_state()

    def get_env(self, time):
        """Format the environment state to pass to the deep learning algorithm."""
        assert self.has_state()

        # combine pose and goal
        pose = np.asarray(self.pose, dtype=np.float32)
        goal = np.asarray(self.goal, dtype=np.float32)
        state = np.concatenate((pose, goal))

        # Determine reward and if done
        reward = 0
        done = False

        if self.prev_score is not None:
            reward += self.GOAL_REWARD * (self.score - self.prev_score)
        self.prev_score = self.score

        if self.prev_time is not None:
            dist = np.sqrt(np.sum(np.square(pose[1:3] - goal)))
            dt = (time - self.prev_time).to_sec()
            reward += dt*(self.BASE_REWARD*exp(-self.EXP_REWARD*dist))
        self.prev_time = time

        if not self.alive:
            reward += self.DEATH_REWARD
            done = True

        # match Gym's env.step() API
        return (state, reward, done, {})

    def reset(self):
        """reset for new episode."""
        self.clear_state()
        self.prev_score = None
        self.prev_time = None

    def pose_cb(self, pose_msg):
        """Callback for poses of each segment of snake."""
        if len(pose_msg.poses) != self.NUM_SEGMENTS:
            rospy.logerr("Bad pose callback")
            return

        yaw, __, __ = euler_from_quaternion((
            pose_msg.poses[0].orientation.x,
            pose_msg.poses[0].orientation.y,
            pose_msg.poses[0].orientation.z,
            pose_msg.poses[0].orientation.w))

        self.pose = tuple(
            [yaw] +
            [func(pose_msg.poses[i]) for i in range(self.NUM_SEGMENTS)
                for func in (
                    lambda pose: pose.position.x,
                    lambda pose: pose.position.y)])
        with self.cond:
            self.cond.notify_all()

    def goal_cb(self, goal_msg):
        """Callback for location of goal."""
        self.goal = (goal_msg.point.x, goal_msg.point.y)
        with self.cond:
            self.cond.notify_all()

    def score_cb(self, score_msg):
        """Callback for score of game."""
        self.score = score_msg.data
        with self.cond:
            self.cond.notify_all()

    def alive_cb(self, alive_msg):
        """Callback for active state of snake."""
        self.alive = alive_msg.data
        with self.cond:
            self.cond.notify_all()

    def load_cb(self, load_msg):
        """Callback to load model weights."""
        self.agent.load(load_msg.data)

    def save_cb(self, save_msg):
        """Callback to save model weights."""
        self.agent.save(save_msg.data)

class Trainer(SnakeDQN):
    """Class for training the agent."""
    def __init__(self):
        super().__init__()

        # Constants
        self.DELTA_T = rospy.Duration.from_sec(1.0 / rospy.get_param('~rate', 30.0))
        self.MAX_T   = rospy.Duration.from_sec(rospy.get_param('~max_episode_time', 60.0))

        # Publishers
        self.clock_pub = rospy.Publisher('/clock', Clock, queue_size=1)
        self.log_pub = rospy.Publisher('snake/dqn/training', DiagnosticStatus, queue_size=1)

        # Services
        self.reset_srv = rospy.ServiceProxy('snake/reset', Empty)

        self.time = rospy.Time.from_sec(time.time())
        self.start_time = rospy.Time.from_sec(self.time.to_sec())

        # Main loop
        try:
            # wait for snake to initialize
            rospy.loginfo("Waiting for snake to initialize.")
            while not self.wait_for_state():
                self.time += self.DELTA_T
                self.clock_pub.publish(self.time)
            rospy.loginfo("Done.")

            # initialize variables
            self.reset()

            # train
            self.train(rospy.get_param('~num_episodes', 1000))

            # idle wait to allow saving weights, etc
            rospy.loginfo("Done Training.")
            rospy.spin()
        except rospy.ROSInterruptException:
            pass

    def train(self, num_episodes):
        for episode in range(num_episodes):
            # reset episode and get initial state
            obs, reward, done, __ = self.reset_env()

            net_reward = reward
            steps = 0
            while not done:
                action = self.agent.act((obs, reward, done, {}))
                state, reward, done, __ = self.step(action)

                net_reward += reward
                steps += 1

            log_msg = DiagnosticStatus()
            log_msg.name = "DQN training"
            log_msg.values.append(KeyValue(key="episode", value=str(episode+1)))
            log_msg.values.append(KeyValue(key="score", value=str(self.score)))
            log_msg.values.append(KeyValue(key="net_reward", value=str(net_reward)))
            log_msg.values.append(KeyValue(key="steps", value=str(steps)))
            log_msg.values.append(KeyValue(key="epsilon", value=str(self.agent.policy.epsilon)))
            self.log_pub.publish(log_msg)

    def step(self, action):
        """Step simulation one time step and return new state."""
        # Publish action
        self.clear_state()
        self.action_pub.publish(self.get_action_msg(action))

        # Advance time
        self.time += self.DELTA_T
        self.clock_pub.publish(self.time)

        # Wait for snake
        if not self.wait_for_state():
            rospy.logwarn("Timeout waiting to get state from sim; Attempting small time advance.")
            self.time += 0.25*self.DELTA_T
            self.clock_pub.publish(self.time)
            if not self.wait_for_state():
                rospy.logwarn("Small time advance failed; Attempting large time advance.")
                self.time += self.DELTA_T
                self.clock_pub.publish(self.time)
                if not self.wait_for_state():
                    rospy.logerr("Failed to get state from sim. Exiting")
                    sys.exit(1)

        # return state
        state, reward, done, dict = self.get_env(self.time)
        if self.time - self.start_time >= self.MAX_T:
          done = True

        return (state, reward, done, dict)

    def reset_env(self):
        """Reset the environment for new episode."""
        # Clear last action
        self.action_pub.publish(Twist())

        # Reset
        self.reset_srv.call()
        self.reset()

        # Advance time (twice due to how sim's internal reset works)
        self.time += self.DELTA_T
        self.clock_pub.publish(self.time)
        self.time += self.DELTA_T
        self.clock_pub.publish(self.time)

        # Wait for snake
        if not self.wait_for_state():
            rospy.logwarn("Timeout waiting to get state from sim after reset; Attempting small time advance.")
            self.time += 0.25*self.DELTA_T
            self.clock_pub.publish(self.time)
            if not self.wait_for_state():
                rospy.logwarn("Small time advance failed; Attempting large time advance.")
                self.time += self.DELTA_T
                self.clock_pub.publish(self.time)
                if not self.wait_for_state():
                    rospy.logerr("Failed to get state from sim after reset. Exiting")
                    sys.exit(1)

        self.start_time = rospy.Time.from_sec(self.time.to_sec())

        # return initial state
        return self.get_env(self.time)

class Evaluator(SnakeDQN):
    """Class for running the agent live."""
    def __init__(self):
        super().__init__()

        # Services
        self.reset_srv = rospy.Service('snake_dqn/reset', Empty, self.reset_cb)

        self.lock = Lock()

        try:
            # initialize variables
            self.reset()

            while not rospy.is_shutdown():
                self.lock.acquire()

                # Wait for state
                while not self.wait_for_state():
                    pass

                # update state
                state, __, done, __ = self.get_env(rospy.Time.now())

                # check for end of game and react
                if not done:
                    self.clear_state()
                    self.action_pub.publish(
                        self.get_action_msg(
                            self.agent.eval((state, 0.0, done, {}))))

                self.lock.release()

        except rospy.ROSInterruptException:
            pass

    def reset_cb(self, reset_srv):
        """Thread safe reset."""
        with self.lock:
            self.reset()
        return EmptyResponse()

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--training":
        print("Starting DQN node for training")
        Trainer()
    else:
        print("Starting DQN node for evaluation")
        Evaluator()
