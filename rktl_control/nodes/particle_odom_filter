#!/usr/bin/env python3
"""Node to estimate odometry from poses over time using a Kalman filter.
License:
  BSD 3-Clause License
  Copyright (c) 2020, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
"""

# ROS
import rospy
from nav_msgs.msg import Odometry
from geometry_msgs.msg import PoseWithCovarianceStamped
from tf.transformations import euler_from_quaternion, quaternion_from_euler

import numpy as np
from pfilter import ParticleFilter
from math import sin, cos, tan, atan, pi, exp

class ParticleOdomFilter(object):
    """Class to estimate pose and velocity using Kalman filter."""
    def __init__(self):
        rospy.init_node('particle_odom_filter')

        # constants
        self.MAP_FRAME = rospy.get_param('~frame_ids/map', 'map')
        self.BODY_FRAME = rospy.get_param('~frame_ids/body', 'base_link')

        # OTHER CONSTANTS HERE
        self.CAR_LENGTH = 0.01
        self.MAX_SPEED = 1.0
        self.THROTTLE_TAU = 0.25
        self.STEERING_THROW = np.deg2rad(15)
        self.STEERING_RATE = np.deg2rad(30)
        self.MEAS_DIR_STD_DEV = 0.05
        self.MEAS_LOC_STD_DEV = np.deg2rad(5)
        self.NUM_PARTICLES = 1000
        self.DELTA_T = 0.1
        self.FIELD_WIDTH = 3
        self.FIELD_HEIGHT = 4.25

        # variables
        self.filter = ParticleFilter(
            prior_fn=self.particle_init, 
            dynamics_fn=self.particle_dynamics,
            observe_fn=self.particle_observation,
            weight_fn=self.particle_weight,
            n_particles=self.NUM_PARTICLES,
            resample_proportion=0.1)

        # pubs / subs
        self.odom_pub = rospy.Publisher('odom', Odometry, queue_size=1)
        rospy.Subscriber('pose', PoseWithCovarianceStamped, self.pose_cb)

        # main loop
        rospy.spin()

    def pose_cb(self, pose_msg):
        """Callback for new poses."""
        assert(pose_msg.header.frame_id == self.MAP_FRAME)

        # deconstruct message
        x = pose_msg.pose.pose.position.x
        y = pose_msg.pose.pose.position.y
        __, __, yaw = euler_from_quaternion([
            pose_msg.pose.pose.orientation.x,
            pose_msg.pose.pose.orientation.y,
            pose_msg.pose.pose.orientation.z,
            pose_msg.pose.pose.orientation.w
        ])
        observation = np.array([x, y, yaw])

        # filter
        self.filter.update(observation)
        state = self.filter.mean_state

        # convert to odometry
        beta = atan(tan(state[4]) / 2.0)
        v_body = state[3] / cos(beta)
        curvature = 2.0 * sin(beta) / self.CAR_LENGTH
        x = state[0]
        y = state[1]
        theta = state[2]
        vx_body = v_body * cos(beta)
        vy_body = v_body * sin(beta)
        omega = v_body * curvature

        # publish message
        odom_msg = Odometry()
        odom_msg.header = pose_msg.header
        odom_msg.child_frame_id = self.BODY_FRAME
        odom_msg.pose.pose.position.x = x
        odom_msg.pose.pose.position.y = y
        x, y, z, w = quaternion_from_euler(0, 0, theta)
        odom_msg.pose.pose.orientation.x = x
        odom_msg.pose.pose.orientation.y = y
        odom_msg.pose.pose.orientation.z = z
        odom_msg.pose.pose.orientation.w = w
        odom_msg.twist.twist.linear.x = vx_body
        odom_msg.twist.twist.linear.y = vy_body
        odom_msg.twist.twist.angular.z = omega
        self.odom_pub.publish(odom_msg)

    def particle_dynamics(self, particles):
        """Extrapolate all particles to future state, including random control noise."""
        # create random control noise
        # throttle between 0.5 and 1.0, steering -1.0 to 1.0
        rng = np.random.default_rng()
        v_rear_ref = rng.random(self.NUM_PARTICLES) * 0.5 + 0.5
        psi_ref = rng.random(self.NUM_PARTICLES) * 2.0 - 1.0

        # extract some states from particles matrix
        theta = particles[:,2]
        v_rear = particles[:,3]
        psi = particles[:,4]

        # update rear wheel velocity using 1st order model
        v_rear = (v_rear - v_rear_ref) * exp(-self.DELTA_T/self.THROTTLE_TAU) + v_rear_ref

        # update steering angle using massless acceleration to a fixed rate
        psi = np.where(np.abs(psi_ref - psi) < self.STEERING_RATE*self.DELTA_T,
            psi_ref,
            np.where(psi_ref > psi,
                psi + self.STEERING_RATE*self.DELTA_T,
                psi - self.STEERING_RATE*self.DELTA_T
            )
        )

        # using bicycle model, extrapolate future state
        return np.array([
            self.DELTA_T * v_rear * np.cos(theta + np.arctan(np.tan(psi) / 2.0)) * np.sqrt(np.square(np.tan(psi)) / 4.0 + 1),
            self.DELTA_T * v_rear * np.sin(theta + np.arctan(np.tan(psi) / 2.0)) * np.sqrt(np.square(np.tan(psi)) / 4.0 + 1),
            self.DELTA_T * v_rear * np.tan(psi) / self.CAR_LENGTH,
            v_rear,
            psi]).T

    def particle_observation(self, particles):
        """Calculate expected measurements for each particle."""
        return particles[:,0:3]

    def particle_weight(self, expected, observed):
        """Weigh each particle based off difference between observed and expected measurements."""
        # compute error
        error = expected - observed

        # use a standard normal distribution pdf
        sigma = np.array([self.MEAS_DIR_STD_DEV, self.MEAS_DIR_STD_DEV, self.MEAS_LOC_STD_DEV])
        base = 2.0 * pi * np.square(sigma)
        probabilities = base * np.exp(np.square(error / sigma) / -2.0)
   
        # assume each state is independent
        return probabilities[:,0] * probabilities[:,1] * probabilities[:,2]

    def particle_init(self, num_particles):
        """Initial guesses for particle states."""
        rng = np.random.default_rng()
        return (
            rng.random((num_particles, 5))
            * np.array([self.FIELD_WIDTH, self.FIELD_HEIGHT, 2.0*pi, 0.0, 0.0])
            - np.array([self.FIELD_WIDTH/2.0, self.FIELD_HEIGHT/2.0, pi, 0.0, 0.0])
        )

if __name__ == "__main__":
    ParticleOdomFilter()