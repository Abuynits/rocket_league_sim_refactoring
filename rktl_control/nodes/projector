#!/usr/bin/env python3
"""Create a depth map to project camera data onto ground plane
License:
  BSD 3-Clause License
  Copyright (c) 2022, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
"""

# ROS
from ctypes import sizeof
import rospy
from geometry_msgs.msg import PoseWithCovarianceStamped
from sensor_msgs.msg import Image, CameraInfo
from tf.transformations import translation_matrix, quaternion_matrix

import numpy as np

class Projector(object):
    """Class to synchronize and buffer all poses."""
    def __init__(self):
        rospy.init_node('projector')

        self.depth_pub = rospy.Publisher('cam0/depth_rect', Image, queue_size=1)
        rospy.Subscriber('cam0/camera_info', CameraInfo, self.camera_info_cb)

        # remove this when TF is implemented
        rospy.Subscriber('cam0', PoseWithCovarianceStamped, self.pose_cb)
        self.map_to_cam = None

        rospy.spin()

    def pose_cb(self, pose_msg):
        """Replace this with TF tree once implemented."""
        # pull translation and quaternion from pose msg
        translation = np.array([
            pose_msg.pose.pose.position.x,
            pose_msg.pose.pose.position.y,
            pose_msg.pose.pose.position.z])
        quaternion = np.array([
            pose_msg.pose.pose.orientation.x,
            pose_msg.pose.pose.orientation.y,
            pose_msg.pose.pose.orientation.z,
            pose_msg.pose.pose.orientation.w])
        # create homographic matrix
        self.map_to_cam = np.linalg.inv(
            translation_matrix(translation) @ quaternion_matrix(quaternion))

    def camera_info_cb(self, info_msg):
        """Callback for creating depth map"""
        # replace this with a call to TF
        map_to_cam = self.map_to_cam
        if map_to_cam is None:
            return

        # ground plane in map space (X direction, Y direction, origin point)
        # any [a,b,1].T input results in a point on the ground plane
        ground_plane = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1]]).T
        # convert to camera space
        ground_plane = map_to_cam @ ground_plane

        # extract camera projection matrix from msg
        cam_to_img = np.array(info_msg.P).reshape((3,4))

        # depth * [i,j,1].T = cam_to_img x ground_plane x [a,b,1].T
        # [i,j,1].T = cam_to_img x ground_plane x [A,B,1/depth].T

        # create matrix of all pixels
        w = info_msg.width
        h = info_msg.height
        i = np.arange(stop=w).reshape((w,1,1,1))
        j = np.arange(stop=h).reshape((1,h,1,1))

        i = np.broadcast_to(i, (w,h,1,1))
        j = np.broadcast_to(j, (w,h,1,1))
        k = np.broadcast_to(1, (w,h,1,1))

        img = np.concatenate((i,j,k), axis=2)

        # reshape matrix
        mat = (cam_to_img @ ground_plane).reshape((1,1,3,3))
        mat = np.broadcast_to(mat, (w,h,3,3))

        # solve for all pixels at once
        depth = np.linalg.solve(mat, img)
        # extract depth
        depth = 1/(depth[:,:,2,0]).reshape((w,h))

        # convert to required format for ROS
        depth = depth.astype('float32', order='C')
        depth = np.ascontiguousarray(depth)

        # create message
        img_msg = Image()
        img_msg.header = info_msg.header
        # img_msg.header.stamp = rospy.Time.now()
        img_msg.height = h
        img_msg.width = w
        img_msg.encoding = '32FC1'
        img_msg.step = 4*w
        img_msg.data = depth.tobytes()

        # publish
        self.depth_pub.publish(img_msg)

if __name__ == "__main__":
    Projector()