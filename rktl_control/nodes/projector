#!/usr/bin/env python3
"""Create a depth map to project camera data onto ground plane
License:
  BSD 3-Clause License
  Copyright (c) 2022, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
"""

# ROS
import rospy
from sensor_msgs.msg import Image, CameraInfo
from tf2_ros import Buffer, TransformListener
from tf.transformations import translation_matrix, quaternion_matrix

import numpy as np

class Projector(object):
    """Class to synchronize and buffer all poses."""
    def __init__(self):
        rospy.init_node('projector')

        self.FRAME = rospy.get_param('~cam_frame', 'cam0')
        self.depth_pub = rospy.Publisher(f'{self.FRAME}/depth_rect', Image, queue_size=1)
        rospy.Subscriber(f'{self.FRAME}/camera_info', CameraInfo, self.camera_info_cb)

        self.buffer = Buffer()
        listener = TransformListener(self.buffer)

        rospy.spin()

    def camera_info_cb(self, info_msg):
        """Callback for creating depth map"""
        # get camera location via TF tree
        try:
            map_to_cam_msg = self.buffer.lookup_transform('map', self.FRAME, rospy.Time())
        except:
            return

        # pull translation and quaternion from pose msg
        translation = np.array([
            map_to_cam_msg.transform.translation.x,
            map_to_cam_msg.transform.translation.y,
            map_to_cam_msg.transform.translation.z])
        quaternion = np.array([
            map_to_cam_msg.transform.rotation.x,
            map_to_cam_msg.transform.rotation.y,
            map_to_cam_msg.transform.rotation.z,
            map_to_cam_msg.transform.rotation.w])
        # create homographic matrix
        map_to_cam = (
            translation_matrix(translation) @ quaternion_matrix(quaternion))

        # ground plane in map space (X direction, Y direction, origin point)
        # any [a,b,1].T input results in a point on the ground plane
        ground_plane = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1]]).T
        # convert to camera space
        ground_plane = map_to_cam @ ground_plane

        # extract camera projection matrix from msg
        cam_to_img = np.array(info_msg.P).reshape((3,4))

        # depth * [i,j,1].T = cam_to_img x ground_plane x [a,b,1].T
        # [i,j,1].T = cam_to_img x ground_plane x [A,B,1/depth].T

        # create matrix of all pixels
        w = info_msg.width
        h = info_msg.height
        i = np.arange(stop=w).reshape((w,1,1,1))
        j = np.arange(stop=h).reshape((1,h,1,1))

        i = np.broadcast_to(i, (w,h,1,1))
        j = np.broadcast_to(j, (w,h,1,1))
        k = np.broadcast_to(1, (w,h,1,1))

        img = np.concatenate((i,j,k), axis=2)

        # reshape matrix
        mat = (cam_to_img @ ground_plane).reshape((1,1,3,3))
        mat = np.broadcast_to(mat, (w,h,3,3))

        # solve for all pixels at once
        depth = np.linalg.solve(mat, img)
        # extract depth
        depth = 1000/(depth[:,:,2,0]).reshape((w,h))

        # convert to required format for ROS
        depth = depth.astype('uint16')
        depth = np.ascontiguousarray(depth)

        # create message
        img_msg = Image()
        img_msg.header = info_msg.header
        # img_msg.header.stamp = rospy.Time.now()
        img_msg.height = h
        img_msg.width = w
        img_msg.encoding = '16UC1'
        img_msg.step = 2*w
        img_msg.data = depth.tobytes()

        # publish
        self.depth_pub.publish(img_msg)

if __name__ == "__main__":
    Projector()