#!/usr/bin/env python3
"""Create a depth map to project camera data onto ground plane
License:
  BSD 3-Clause License
  Copyright (c) 2022, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
"""

# ROS
import rospy
from geometry_msgs.msg import PoseWithCovarianceStamped
from sensor_msgs.msg import Image, CameraInfo
from tf.transformations import translation_matrix, quaternion_matrix

import numpy as np

class Projector(object):
    """Class to synchronize and buffer all poses."""
    def __init__(self):
        rospy.init_node('projector')

        self.depth_pub = rospy.Publisher('cam0/depth_rectified', Image, queue_size=1)
        rospy.Subscriber('cam0/camera_info', CameraInfo, self.camera_info_cb)

        # remove this when TF is implemented
        rospy.Subscriber('cam0', PoseWithCovarianceStamped, self.pose_cb)
        self.cam_tf = None

        rospy.spin()

    def pose_cb(self, pose_msg):
        """Replace this with TF tree once implemented."""
        # pull translation and quaternion from pose msg
        translation = np.array([
            pose_msg.pose.pose.position.x,
            pose_msg.pose.pose.position.y,
            pose_msg.pose.pose.position.z])
        quaternion = np.array([
            pose_msg.pose.pose.orientation.x,
            pose_msg.pose.pose.orientation.y,
            pose_msg.pose.pose.orientation.z,
            pose_msg.pose.pose.orientation.w])
        # create homographic matrix
        self.map_to_cam = np.linalg.inv(
            translation_matrix(translation) @ quaternion_matrix(quaternion))

    def camera_info_cb(self, info_msg):
        """Callback for creating depth map"""
        # replace this with a call to TF
        map_to_cam = self.map_to_cam
        if map_to_cam is None:
            return

        # ground plane in map space (X direction, Y direction, origin point)
        # any [a,b,1].T input results in a point on the ground plane
        ground_plane = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1]]).T
        # convert to camera space
        ground_plane = map_to_cam @ ground_plane

        # extract camera projection matrix from msg
        cam_to_img = np.array(info_msg.P).reshape((3,4))

        # depth * [i,j,1].T = cam_to_img x ground_plane x [a,b,1].T
        # [i,j,1].T = cam_to_img x ground_plane x [A,B,1/depth].T

        i = 0
        j = 0
        img = np.array([i, j, 1])
        # do this for each pixel?
        depth = np.linalg.solve(cam_to_img @ ground_plane, img)
        # extract depth
        depth = 1/depth[2]

        print(f"depth is {depth}")

if __name__ == "__main__":
    Projector()