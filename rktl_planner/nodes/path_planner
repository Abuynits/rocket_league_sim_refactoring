#!/usr/bin/env python3

import math
import rospy
import numpy as np
from tf.transformations import  euler_from_quaternion
from nav_msgs.msg import Odometry
from std_msgs.msg import Bool
from rktl_msgs.msg import BezierPathList, Path
from rktl_planner.srv import CreateBezierPath
from rktl_planner import path_requests
from enum import Enum

class GameState(Enum):
    IN_POSITION = 0
    TURNED_AROUND = 1
    PAST_BALL = 2

class PlannerState(Enum):
    READY = 0
    EXECUTE_SCORE = 1
    EXECUTE_BACKUP = 2
    EXECUTE_TURN = 3
    EXECUTE_DISLODGE = 4

class PathPlanner(object):
    def __init__(self):
        rospy.init_node('path_planner')

        self.state = PlannerState.READY

        # Subscribers
        car_name = rospy.get_param('~car_name')
        rospy.Subscriber(f'/cars/{car_name}/odom', Odometry, self.car_odom_cb)
        rospy.Subscriber(f'/cars/{car_name}/following_path', Bool, self.car_following_path_cb)
        rospy.Subscriber('/ball/odom', Odometry, self.ball_odom_cb)

        # Services
        rospy.wait_for_service('create_bezier_path')
        self.path_client = rospy.ServiceProxy('create_bezier_path', CreateBezierPath)

        # Publishers
        self.linear_path_pub = rospy.Publisher('linear_path',
            Path, queue_size=1, latch=True)
        self.bezier_path_pub = rospy.Publisher('bezier_path',
            BezierPathList, queue_size=1, latch=True)

        self.car_odom = Odometry()
        self.ball_odom = Odometry()

        self.goal_pos = (rospy.get_param('/field/length', 1) / 2, 0.)
        self.time_left = 0.0
        self.car_following_path = False

        rate = rospy.Rate(10)
        while not rospy.is_shutdown():
            self.loop_once()
            try:
                rate.sleep()
            except rospy.ROSInterruptException:
                pass

    def car_following_path_cb(self, data: Bool):
        self.car_following_path = data.data

    def car_odom_cb(self, data: Odometry):
        self.car_odom = data

    def ball_odom_cb(self, data: Odometry):
        self.ball_odom = data

    def loop_once(self):
        car_orient = self.car_odom.pose.pose.orientation
        car_yaw = euler_from_quaternion(
            np.array([car_orient.x, car_orient.y, car_orient.z, car_orient.w]))[2]
        car_x = self.car_odom.pose.pose.position.x
        ball_x = self.ball_odom.pose.pose.position.x

        game_state = GameState.IN_POSITION
        if car_x > ball_x - 0.5:
            game_state = GameState.PAST_BALL
        if car_yaw > math.pi/2 and car_yaw < 3*math.pi/2:
            game_state = GameState.TURNED_AROUND

        if self.state == PlannerState.READY or not self.car_following_path:
            if game_state == GameState.IN_POSITION:
                self.state = PlannerState.EXECUTE_SCORE
                req = path_requests.create_score_path_req(self.car_odom, self.ball_odom, self.goal_pos)
                res = self.path_client(req)
            elif game_state == GameState.PAST_BALL:
                self.state = PlannerState.EXECUTE_BACKUP
                req = path_requests.create_backup_path_req(self.car_odom, self.goal_pos)
                res = self.path_client(req)
            elif game_state == GameState.TURNED_AROUND:
                self.state = PlannerState.EXECUTE_TURN
                req = path_requests.create_turn_path_req(self.car_odom)
                res = self.path_client(req)

            if self.linear_path_pub:
                self.linear_path_pub.publish(res.linear_path)

            if self.bezier_path_pub:
                bezier_path_list = BezierPathList()
                bezier_path_list.paths = res.bezier_paths
                self.bezier_path_pub.publish(bezier_path_list)

if __name__ == '__main__':
    PathPlanner()
