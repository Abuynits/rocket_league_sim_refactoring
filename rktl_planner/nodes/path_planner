#!/usr/bin/env python3

import math
import rospy
import numpy as np
from tf.transformations import  euler_from_quaternion
from nav_msgs.msg import Odometry
from std_msgs.msg import Bool
from rktl_msgs.msg import BezierPathList, Path
from rktl_planner.srv import CreateBezierPath
from rktl_planner import path_requests
from enum import Enum

class GameState(Enum):
    IN_POSITION = 0
    TURNED_AROUND = 1
    BALL_OFFENSIVE = 2
    BALL_DEFENSIVE = 3

class PlannerState(Enum):
    READY = 0
    EXECUTE_SCORE = 1
    EXECUTE_BACKUP = 2
    EXECUTE_TURN = 3
    EXECUTE_DISLODGE = 4

class PathPlanner(object):
    def __init__(self):
        rospy.init_node('path_planner')

        self.state = PlannerState.READY

        # Subscribers
        car_name = rospy.get_param('~car_name')
        rospy.Subscriber(f'/cars/{car_name}/odom', Odometry, self.car_odom_cb)
        rospy.Subscriber(f'/cars/{car_name}/following_path', Bool, self.car_following_path_cb)
        rospy.Subscriber('/ball/odom', Odometry, self.ball_odom_cb)

        # Services
        rospy.wait_for_service('create_bezier_path')
        self.path_client = rospy.ServiceProxy('create_bezier_path', CreateBezierPath)

        # Publishers
        self.linear_path_pub = rospy.Publisher('linear_path',
            Path, queue_size=1, latch=True)
        self.bezier_path_pub = rospy.Publisher('bezier_path',
            BezierPathList, queue_size=1, latch=True)

        self.car_odom = Odometry()
        self.ball_odom = Odometry()

        self.goal_pos = (rospy.get_param('/field/length', 1) / 2, 0.)
        self.time_left = 0.0
        self.car_following_path = False

        rate = rospy.Rate(10)
        while not rospy.is_shutdown():
            self.loop_once()
            try:
                rate.sleep()
            except rospy.ROSInterruptException:
                pass

    def car_following_path_cb(self, data: Bool):
        self.car_following_path = data.data

    def car_odom_cb(self, data: Odometry):
        self.car_odom = data

    def ball_odom_cb(self, data: Odometry):
        self.ball_odom = data

    def loop_once(self):
        car_orient = self.car_odom.pose.pose.orientation
        car_yaw = euler_from_quaternion(
            np.array([car_orient.x, car_orient.y, car_orient.z, car_orient.w]))[2]
        car_x = self.car_odom.pose.pose.position.x
        ball_x = self.ball_odom.pose.pose.position.x

        # game_state = GameState.IN_POSITION
        # if car_x > ball_x - 1.0:
        #     game_state = GameState.PAST_BALL
        # if car_yaw > math.pi/2 and car_yaw < 3*math.pi/2:
        #     game_state = GameState.TURNED_AROUND

        res = None
        if self.state == PlannerState.READY or not self.car_following_path:
            if ball_x > 0:
                if car_x > (ball_x-0.5):
                    self.state = PlannerState.EXECUTE_BACKUP
                    req = path_requests.create_backup_path_req(self.car_odom, self.goal_pos)
                    res = self.path_client(req)

                    if res.linear_path.max_curvature > 2.0:
                        print(res.linear_path.max_curvature)
                        req = path_requests.create_backup_path_req(self.car_odom, self.goal_pos, bkw=False)
                        res = self.path_client(req)
                else:
                    self.state = PlannerState.EXECUTE_SCORE
                    req = path_requests.create_score_path_req(self.car_odom, self.ball_odom, self.goal_pos)
                    res = self.path_client(req)

                    if res.linear_path.max_curvature > 2.0:
                        req = path_requests.create_score_path_req(self.car_odom, self.ball_odom, self.goal_pos, bkw=True)
                        res = self.path_client(req)

                    if res.linear_path.max_curvature > 2.0:
                        self.state = PlannerState.EXECUTE_BACKUP
                        req = path_requests.create_backup_path_req(self.car_odom, self.goal_pos)
                        res = self.path_client(req)
                    
                    if res.linear_path.max_curvature > 2.0:
                        req = path_requests.create_backup_path_req(self.car_odom, self.goal_pos, bkw=False)
                        res = self.path_client(req)

                    if res.linear_path.max_curvature > 2.0:
                        self.state = PlannerState.EXECUTE_DISLODGE
                        req = path_requests.create_dislodge_path_req(self.car_odom, self.ball_odom)
                        res = self.path_client(req)
            else:
                if car_x < ball_x:
                    self.state = PlannerState.EXECUTE_DISLODGE
                    req = path_requests.create_dislodge_path_req(self.car_odom, self.ball_odom)
                    res = self.path_client(req)
                
                else:
                    self.state = PlannerState.EXECUTE_BACKUP
                    req = path_requests.create_backup_path_req(self.car_odom, self.goal_pos, bkw=False)
                    res = self.path_client(req)

                    if res.linear_path.max_curvature > 5.0:
                        req = path_requests.create_backup_path_req(self.car_odom, self.goal_pos)
                        res = self.path_client(req)

        if res is not None:  
            if self.linear_path_pub:
                self.linear_path_pub.publish(res.linear_path)

            if self.bezier_path_pub:
                bezier_path_list = BezierPathList()
                bezier_path_list.paths = res.bezier_paths
                self.bezier_path_pub.publish(bezier_path_list)

if __name__ == '__main__':
    PathPlanner()
