#!/usr/bin/env python3
"""Contains the WaypointControllerROS Node.
License:
  BSD 3-Clause License
  Copyright (c) 2020, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
"""

# 3rd party modules
import rospy
import numpy as np
import math
import time
from std_msgs.msg import Float32, Float64
from geometry_msgs.msg import Twist, PoseWithCovarianceStamped, PoseArray, Pose
from nav_msgs.msg import Odometry

# Local modules
import rktl_planner.convert as convert
import rktl_planner.pure_pursuit as pursuit
from rktl_msgs.msg import Target, Path, PathError, Waypoint


class WaypointControllerROS(object):
    """A node to ensure the car follows a given trajectory."""

    def __init__(self):
        rospy.init_node('waypoint_controller_node')

        self.path_start_time = None
        self.path = None
        self.last_pose_idx = None
        self.start_time = None
        self.max_speed = None

        self.frame_id = rospy.get_param('~frame_id', 'map')

        # Max speed to travel path
        self.max_speed = rospy.get_param('~max_speed', 0.1)

        # Radius to search for intersections
        self.lookahead_dist = rospy.get_param('~lookahead_dist', 0.15)

        # Coeffient to adjust lookahead distance by speed
        self.lookahead_gain = rospy.get_param('~lookahead_gain', 0.035)

        # Number of waypoints to search per pass (-1 is full path)
        self.lookahead_pnts = rospy.get_param('~lookahead_pnts', -1)

        # Enables debug publishers such as lookahead_pnt pose
        self.is_debug = rospy.get_param('~is_debug', True)

        # Publishers
        self.bot_velocity_cmd = rospy.Publisher('car0/cmd_vel',
                                                Twist, queue_size=1)

        self.path_error_pub = rospy.Publisher(
            'car0/path_error', PathError, queue_size=1)

        if self.is_debug:
            self.lookahead_dist_pub = rospy.Publisher('car0/lookahead_dist',
                                                     Float32,
                                                     queue_size=1)
            self.d_angle_pub = rospy.Publisher(
                'car0/d_angle', Float32, queue_size=1)

        # Subscribers
        rospy.Subscriber('car0/path', Path, self.path_cb)
        rospy.Subscriber('car0/odom', Odometry, self.odom_cb)

        rospy.spin()

    def path_cb(self, path_arr_msg):
        """Creates path using waypoints in Path message."""
        self.path_start_time = path_arr_msg.header.stamp
        self.bkw = path_arr_msg.backwards
        print(self.bkw, path_arr_msg.backwards)
        self.path = path_arr_msg.waypoint
        self.last_pnt_idx = 0
        self.start_time = time.time()

    def odom_cb(self, odom_msg):
        """Updates car odometry and follows current path."""
        if self.path:
            if self.last_pose_idx == None:
                self.last_pose_idx = 0

            # Converting odom msg to numpy arrays
            bot_pos, bot_orient, _ = convert.pose_covar_to_array(odom_msg.pose)
            bot_linear, bot_angular, _ = convert.twist_covar_to_array(
                odom_msg.twist)

            # Set lookahead dist by lookahead gain and current speed
            lookahead_boost = np.linalg.norm(bot_linear) \
                * self.lookahead_gain
            lookahead_dist = self.lookahead_dist + lookahead_boost

            # Set number of waypoints to check
            if self.lookahead_pnts == -1:
                lookahead_pnts = len(self.path)
            else:
                lookahead_pnts = self.lookahead_pnts

            # Find next valid intersection along path
            intersect = None
            goal_pos = None
            goal_vel = None
            goal_time = None
            vel_margin = None
            i = self.last_pose_idx
            pnts_checked = 0
            while pnts_checked < lookahead_pnts:
                if i == len(self.path) - 1:
                    i = 0

                start_pos, _ = convert.pose_to_array(self.path[i].pose)
                end_pos, _ = convert.pose_to_array(self.path[i + 1].pose)

                path_seg = end_pos - start_pos
                bot_path = start_pos - bot_pos

                intersect = pursuit.find_intersection(path_seg, bot_path,
                    lookahead_dist)

                if intersect is not None:
                    self.last_pose_idx = i
                    intersect += start_pos

                    # Check if intersection is behind vehicle
                    goal_pos = end_pos
                    goal_vel = np.linalg.norm(convert.twist_to_array(self.path[i + 1].twist))
                    goal_time = self.path[i + 1].delta_t
                    vel_margin = self.path[i + 1].velocity_tolerance.data
                    d_angle = pursuit.calculate_angle(intersect, bot_pos,
                        bot_orient, lookahead_dist, self.bkw)
                    if abs(d_angle) > math.pi/2:
                        intersect = None
                    else:
                        break

                i += 1
                pnts_checked += 1

            # If no intersection found, stop moving
            if intersect is None:
                self.bot_velocity_cmd.publish(Twist())
                rospy.logwarn("No intersection could be found.")
                return

            if self.is_debug:
                self.lookahead_dist_pub.publish(Float32(lookahead_dist))

            # Calculate ETA
            dist = np.linalg.norm(goal_pos - bot_pos)
            delta_time = time.time() - self.start_time
            time_left = goal_time.data - delta_time
            
            linear_vel = goal_vel
            if self.bkw:
                linear_vel *= -0.25

            # if time_left <= 0:
            #     # Report unfeasible path
            #     linear_vel = 0
            #     vel_error = goal_vel
            #     rospy.logwarn("Path unfeasible to complete.")
            # else:
            #     linear_vel = dist / time_left
            #     if goal_vel < 0:
            #         linear_vel *= -1
            #     vel_error = goal_vel - linear_vel

            #     if vel_error > vel_margin:
            #         linear_vel = 0
            #         rospy.logwarn("Path unfeasible to complete.")
            #         # TODO: Tell highlevel planner we stopped

            # Calculate angular velocity
            turn_rad = pursuit.calculate_turn_rad(intersect, bot_pos,
                                                  bot_orient, lookahead_dist, self.bkw)
            angular_vel = pursuit.get_angular_speed(linear_vel, turn_rad)

            # Steering-Angle Approach
            # lat_error = pursuit.calculate_lat_error(intersect, bot_pos, \
            #                                         bot_orient, lookahead_dist)
            # angular_vel = math.atan2(2 * lat_error * .125,
            #                          lookahead_dist * lookahead_dist)

            # Publish command data
            twist = Twist()
            twist.linear.x = linear_vel
            twist.angular.z = -angular_vel
            self.bot_velocity_cmd.publish(twist)

            # Publish error data
            # error = PathError()
            # error.time = Float32(time_left)
            # error.position = Float32(dist)
            # error.orientation = Float32()
            # error.linear_velocity = Float32(vel_error)
            # error.angular_velocity = Float32()
            # self.path_error_pub.publish(error)


if __name__ == "__main__":
    WaypointControllerROS()
