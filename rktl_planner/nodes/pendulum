#!/usr/bin/env python3
"""Contains the Pendulum node, a very simple planner.
License:
  BSD 3-Clause License
  Copyright (c) 2022, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
"""

import rospy
from tf.transformations import euler_from_quaternion
from nav_msgs.msg import Odometry
from rktl_msgs.msg import ControlCommand

import math
from angles import shortest_angular_distance as sad

class Pendulum(object):
    """A very simple strategy for rktl."""

    def __init__(self):
        rospy.init_node('path_follower')

        # physical constants (global)
        self.FIELD_WIDTH = rospy.get_param('/field/width')
        self.FIELD_HEIGHT = rospy.get_param('/field/length')
        self.MAX_CURVATURE = math.tan(rospy.get_param('/cars/steering/max_throw')) / rospy.get_param('/cars/length')

        # constants
        self.SPEED = rospy.get_param('~speed', 0.5)
        self.WALL_MARGIN = rospy.get_param('~margins/wall', 0.5)
        self.HEADING_MARGIN = rospy.get_param('~margins/heading', math.pi/4.0)
        self.TURNING_MARGIN = rospy.get_param('~margins/turning', 0.5)

        self.CURVATURE_GAIN = rospy.get_param('~gains/curvature', 1.0)

        # variables
        self.ball_position = None
        self.ball_velocity = None

        # Publishers
        self.cmd_pub = rospy.Publisher('command', ControlCommand, queue_size=1)

        # Subscribers
        rospy.Subscriber('odom', Odometry, self.car_odom_cb)
        rospy.Subscriber('/ball/odom', Odometry, self.ball_odom_cb)

        rospy.spin()

    def ball_odom_cb(self, odom_msg):
        """Callback for ball odometry."""
        self.ball_position = (
            odom_msg.pose.pose.position.x,
            odom_msg.pose.pose.position.y
        )
        self.ball_velocity = (
            odom_msg.twist.twist.linear.x,
            odom_msg.twist.twist.linear.y,
        )

    def car_odom_cb(self, odom_msg):
        """Callback for car odometry."""
        if self.ball_position is None or self.ball_velocity is None:
            return

        # extract car's position & heading
        x = odom_msg.pose.pose.position.x
        y = odom_msg.pose.pose.position.y
        __, __, yaw = euler_from_quaternion([
            odom_msg.pose.pose.orientation.x,
            odom_msg.pose.pose.orientation.y,
            odom_msg.pose.pose.orientation.z,
            odom_msg.pose.pose.orientation.w
        ])

        # calculate distances / errors
        NORTH_WALL_DISTANCE = abs(x - self.FIELD_HEIGHT/2.0)
        SOUTH_WALL_DISTANCE = abs(x + self.FIELD_HEIGHT/2.0)
        EAST_WALL_DISTANCE = abs(y + self.FIELD_WIDTH/2.0)
        WEST_WALL_DISTANCE = abs(y - self.FIELD_WIDTH/2.0)

        NORTH_HEADING_ERROR = sad(yaw, 0.0)
        SOUTH_HEADING_ERROR = sad(yaw, math.pi)
        EAST_HEADING_ERROR = sad(yaw, -math.pi/2.0)
        WEST_HEADING_ERROR = sad(yaw, +math.pi/2.0)

        # Prep command message for publish
        cmd_msg = ControlCommand()

        # if the car is near a wall and facing it, reverse
        if (NORTH_WALL_DISTANCE < self.WALL_MARGIN and abs(NORTH_HEADING_ERROR) < self.HEADING_MARGIN or
            SOUTH_WALL_DISTANCE < self.WALL_MARGIN and abs(SOUTH_HEADING_ERROR) < self.HEADING_MARGIN or
            EAST_WALL_DISTANCE  < self.WALL_MARGIN and abs(EAST_HEADING_ERROR)  < self.HEADING_MARGIN or
            WEST_WALL_DISTANCE  < self.WALL_MARGIN and abs(WEST_HEADING_ERROR)  < self.HEADING_MARGIN):
                cmd_msg.velocity = -self.SPEED
                cmd_msg.curvature = 0.0
                self.cmd_pub.publish(cmd_msg)
                return

        # otherwise, assume the car has clearance to try to align with the
        # desired direction

        # check to see if it is at the top or bottom, where it should be curving
        if (NORTH_WALL_DISTANCE < 1.0/self.MAX_CURVATURE + self.TURNING_MARGIN or
            SOUTH_WALL_DISTANCE < 1.0/self.MAX_CURVATURE + self.TURNING_MARGIN):
                cmd_msg.velocity = self.SPEED
                cmd_msg.curvature = self.MAX_CURVATURE
                self.cmd_pub.publish(cmd_msg)
                return

        # otherwise, assume it is along the right or left wall and wants to go
        # straight up or down

        if (EAST_WALL_DISTANCE > WEST_WALL_DISTANCE):
            # left wall (180 degree heading desired)
            cmd_msg.velocity = self.SPEED
            cmd_msg.curvature = self.MAX_CURVATURE * self.CURVATURE_GAIN * SOUTH_HEADING_ERROR
            self.cmd_pub.publish(cmd_msg)

        else:
            # right wall (0.0 heading desired)
            cmd_msg.velocity = self.SPEED
            cmd_msg.curvature = self.MAX_CURVATURE * self.CURVATURE_GAIN * NORTH_HEADING_ERROR
            self.cmd_pub.publish(cmd_msg)

if __name__ == "__main__":
    Pendulum()
