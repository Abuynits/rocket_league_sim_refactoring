#!/usr/bin/env python3

import rospy
import math
from tf.transformations import euler_from_quaternion, quaternion_from_euler
from rktl_planner.srv import CreateBezierPath, CreateBezierPathRequest, CreateBezierPathResponse
from rktl_planner import BezierPath
from rktl_msgs.msg import Path as PathMsg, Waypoint as WaypointMsg
from geometry_msgs.msg import Pose, Point, Vector3
import numpy as np

def vel(pose: Pose, speed: float):
    q = pose.orientation
    angle = euler_from_quaternion([q.x, q.y, q.z, q.w])[2]
    head = Vector3()
    head.x = math.cos(angle)
    head.y = math.sin(angle)
    vel = Vector3()
    vel.x = speed * head.x
    vel.y = speed * head.y
    return vel, head


def line(p: Point, v: Vector3, t: float):
    point = Point()
    point.x = p.x + t * v.x
    point.y = p.y + t * v.y
    point.z = p.z + t * v.z
    return point


def create_segment(start_pose: Pose, end_pose: Pose, velocity: float, 
    duration: rospy.Duration, segment_duration: rospy.Duration):
    control_points = [start_pose.position, end_pose.position]
    start_vel, start_head = vel(start_pose, velocity)
    end_vel, end_head = vel(end_pose, velocity)

    t_val = duration.to_sec() / 3

    control_points.insert(1, line(control_points[0], start_vel, t_val))
    control_points.insert(len(control_points) - 1,
                          line(control_points[-1], end_vel, -t_val))
    path = BezierPath(control_points, duration.to_sec())
    num_segments = math.ceil(duration.to_sec() / segment_duration.to_sec())
    segment_length = duration.to_sec() / num_segments
    segments = []
    for i in range(num_segments - 1):
        path0, path1 = path.split(segment_length)
        segments.append(path0)
        path = path1
    segments.append(path)
    return segments


def bezier_path_server(req: CreateBezierPathRequest):
    velocity = req.velocity
    bezier_segments = []
    durations = []
    for i in range(len(req.target_durations)):
        start_pose = req.target_poses[i]
        end_pose = req.target_poses[i + 1]
        duration = req.target_durations[i].data
        segments = create_segment(start_pose, end_pose, velocity,
            duration, req.bezier_segment_duration.data)
        bezier_segments.extend(segments)
        for segment in segments:
            if len(durations) > 0:
                durations.append(durations[-1] + segment.duration.to_sec())
            else:
                durations.append(segment.duration.to_sec())

    res = CreateBezierPathResponse()

    res.bezier_paths = [x.to_msg() for x in bezier_segments]
    
    res.linear_path = PathMsg()
    res.linear_path.velocity = velocity

    duration = durations[-1]
    segment_length = req.linear_segment_duration.data.to_sec()
    num_segments = math.floor(duration / segment_length)
    max_curv = 0.
    idx = 0
    t = 0.
    for i in range(num_segments):
        curr_pose = bezier_segments[idx].at(t)
        if (t - segment_length) > 0 and (t + segment_length < durations[idx]):
            # Calculate curvature using Menger curvature
            last_pose = bezier_segments[idx].at(t - segment_length)
            next_pose = bezier_segments[idx].at(t + segment_length)

            a = np.array([
                next_pose.x-curr_pose.x,
                next_pose.y-curr_pose.y,
                next_pose.z-curr_pose.z])
            a_len = np.linalg.norm(a)
            
            b = np.array([
                curr_pose.x-last_pose.x,
                curr_pose.y-last_pose.y,
                curr_pose.z-last_pose.z])
            b_len = np.linalg.norm(b)

            c = np.array([
                last_pose.x-next_pose.x,
                last_pose.y-next_pose.y,
                last_pose.z-next_pose.z])
            c_len = np.linalg.norm(c)

            A = 0.5 * np.linalg.norm(np.cross(a, b))

            if a_len != 0. and b_len != 0. and c_len != 0.:
                curv = abs(4 * A / (a_len * b_len * c_len))
                max_curv = max(max_curv, abs(curv))
        
        heading = bezier_segments[idx].angle_at(t)
        quat = quaternion_from_euler(0, 0, heading)
        wp = WaypointMsg()
        wp.pose.position = curr_pose
        wp.pose.orientation.x = quat[0]
        wp.pose.orientation.y = quat[1]
        wp.pose.orientation.z = quat[2]
        wp.pose.orientation.w = quat[3]
        res.linear_path.waypoints.append(wp)
        
        t += segment_length
        if t > durations[idx]:
            idx += 1 
    res.linear_path.max_curvature = max_curv
    
    return res

if __name__ == '__main__':
    rospy.init_node('bezier_path_server')
    service = rospy.Service('create_bezier_path',
        CreateBezierPath, bezier_path_server)
    rospy.spin()
