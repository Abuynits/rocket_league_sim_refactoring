#!/usr/bin/env python

"""Contains the TrajectoryPlannerROS Node.

License:
  BSD 3-Clause License
  Copyright (c) 2020, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
  1. Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
  3. Neither the name of the copyright holder nor the names of its
     contributors may be used to endorse or promote products derived from
     this software without specific prior written permission.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

import rospy

import pdb
from geometry_msgs.msg import PoseWithCovarianceStamped, PoseArray, Pose, Twist
from nav_msgs.msg import Odometry
from std_msgs.msg import Float64, Empty, Float32
import numpy as np
from tf.transformations import euler_from_quaternion, quaternion_from_euler
from rocket_league_msgs.msg import Target, Path, PathError, Waypoint

class TrajectoryPlannerROS(object):
    """A node to plan local car trajectories."""
    def __init__(self):
        rospy.init_node('trajectory_planner_node')

        # Variables
        self.target_pose = None    #Position of goal
        self.bot_pose = None    # Position of car
        self.bot_vel = None    # velocity of car (in car's reference frame)
        self.bot_normalized_vel = None    # velocity of car after being normalized
        self.bot_init_heading = None    # The initial heading of the car (map frame)
        self.final_angular_vel = None   # The final linear velocity requested by the HLP
        self.final_linear_vel = None   # The final angular velocity requested by the HLP
        self.final_time = None   #The final time requested by the HLP

        # Info about the paths we're using
        self.MOVE_SPEED = rospy.get_param('~MOVE_SPEED', 0.08)
        self.final_heading = None    # Final heading of the car so it hits the ball the correct way
        self.final_normalized_heading = None    # Normalized heading vector
        self.main_points = []    # Array of the main points all create_paths use

        # These variables act as parameters to generate a path
        self.DISTANCE_FROM_CAR = rospy.get_param('~DISTANCE_FROM_CAR',0.25)    # Multiplier for distance of 1st main point in front of the car
        self.DISTANCE_FROM_BALL = rospy.get_param('~DISTANCE_FROM_BALL', 0.08)    # Defines the distance away from the ball that our final (lined up) point should be
        self.SECOND_POINT_DISTANCE = rospy.get_param('~SECOND_POINT_DISTANCE', 0.25)    # Multiplier for radial distance of 2nd point from midpoint of 1st and 3rd points
                                          # (adjusts curvature somewhat)
        self.FOLLOW_THROUGH_DISTANCE = rospy.get_param('~FOLLOW_THROUGH_DISTANCE',0.08)

        # This variable determines the number of points published to the waypoint controller
        self.RESOLUTION = rospy.get_param('~RESOLUTION', 5) 

        # Publishers   TODO: fix these
        self.path_pub = rospy.Publisher("car0/path", Path, queue_size=1)
        self.feasibility_pub = rospy.Publisher("car0/target_feasibility",Float32, queue_size=1)

        # Subscribers
        rospy.Subscriber("car0/target", Target, self.target_cb)
        rospy.Subscriber("car0/odom", Odometry, self.car_odom_cb)
        # rospy.Subscriber("trigger", Empty, self.trigger_cb)

        rospy.spin()

    def loop_once(self):
        """ Runs code to generate the paths"""
        #rospy.logwarn("going")
        self.calculate_final_heading()
        self.generate_main_points()

        # This function is swappable
        # self.four_point_path()
       # self.bezier_curves_path(smoothness=2)
        # self.lagrange_functions_path()
        self.hermite_splines_path()
        # self.recursive_splines_path(angle_limit=30,smoothness=10, distance_reduction=0.65)
        self.feasibility_publisher()


    def target_cb(self, target_message):
        """Callback for getting information about goals for the car
        This callback will also trigger a new path generation"""
        self.target_pose = target_message.pose #.position
        vel = target_message.twist
        self.final_linear_vel = vel.linear
        self.final_angular_vel = vel.angular
        self.final_time = target_message.delta_t
        if not rospy.is_shutdown():
            if self.check_if_GO():
                    self.loop_once()

    def car_odom_cb(self, bot_odom_message):
        """ Callback for car pose and velocity"""
        # Pose represents robot's position and orientation
        self.bot_pose = bot_odom_message.pose.pose

        # Get bot velocity vector and normalize it for future calculations
        self.bot_vel = bot_odom_message.twist.twist
        linear_vel = np.array([self.bot_vel.linear.x, self.bot_vel.linear.y])
        mag = np.linalg.norm(linear_vel)
        self.bot_normalized_vel = normalize(linear_vel)

        # Get bot's init vector heading through orientation
        quat = (self.bot_pose.orientation.x,
                self.bot_pose.orientation.y,
                self.bot_pose.orientation.z,
                self.bot_pose.orientation.w)
        __, __, heading = euler_from_quaternion(quat)
        x = np.cos(heading)
        y = np.sin(heading)
        self.bot_init_heading = np.array([x, y])

    def feasibility_publisher(self):
        """publishes feasibility score where higher numbers are bad, 0 is ideal, and negative is impossibl
        TODO: calculate feasibility instead of just setting it to zero"""
        possible = Float32()
        possible = Float32(0.0)
        print(type(possible))

        self.feasibility_pub.publish(possible)


    def check_if_GO(self):   # TODO:  check that I got every included that we need
        """ Checks if needed variables are properly initialized to run loop_once()"""
        if (self.target_pose is not None) and (self.final_time is not None) and (self.bot_pose is not None) and \
            (self.bot_vel is not None) and (self.bot_normalized_vel is not None) and (self.bot_init_heading is not None) \
                and(self.final_linear_vel is not None) and (self.DISTANCE_FROM_CAR is not None) and \
                    (self.DISTANCE_FROM_BALL is not None) and (self.SECOND_POINT_DISTANCE is not None) and\
                         (self.bot_init_heading is not None) and (self.RESOLUTION is not None) and\
                              (self.bot_vel is not None):
            return True
        else:
            return False


    def calculate_final_heading(self):
        """Calculate final vector (final heading)"""
        # Final vector is simply the final linear velocity
        self.final_heading = np.array([self.final_linear_vel.x,self.final_linear_vel.y])
        # Normalize the vector for future calculations
        self.final_normalized_heading = normalize(self.final_heading)


    def waypoints_from_points(self,points):   # TODO: add varying speeds and nonzero angular velocities
        """Converts points from list or numpy array to pose array and sets twists as well"""
        points = np.vstack([points,self.follow_through_path()])
        waypoint_array_msg = Path()
        waypoint_array_msg.child_frame_id = "map"
        waypoint_array_msg.waypoint = []
        for i in range(len(points)):
            new_pose = Pose()
            new_pose.position.x = points[i][0]
            new_pose.position.y = points[i][1]

            new_twist = Twist()

            # Generate quaternion for orientation (they just point at the next point in the path)
            if i + 1 < len(points):
                yaw = np.arctan2(points[i + 1][1]  - points[i][1], points[i + 1][0] - points[i][0])
            else:
                yaw = np.arctan2(self.final_heading[1],self.final_heading[0])
            (new_pose.orientation.x,new_pose.orientation.y,new_pose.orientation.z,\
                new_pose.orientation.w) = quaternion_from_euler(0,0,yaw)
            
            # Add twist
            if i + 1 < len(points):
                new_twist.linear.x = points[i + 1][0]  - points[i][0]
                new_twist.linear.y =  points[i + 1][1] - points[i][1]
                new_twist.linear.z = 0
                new_twist.angular.x = 0
                new_twist.angular.y = 0
                new_twist.angular.z = 0
            else:
                new_twist.linear = self.final_linear_vel
                new_twist.angular.x = 0
                new_twist.angular.y = 0
                new_twist.angular.z = 0

            # create a new waypoint and add it to the array of them
            new_waypoint = Waypoint()
            new_waypoint.pose = new_pose
            new_waypoint.twist = new_twist
            waypoint_array_msg.waypoint.append(new_waypoint)

        print("ready to publish")
        return waypoint_array_msg

    def create_spline(self, init_position, init_heading, final_position, final_heading, second_point_distance):
        """
        Generate 3 points using spline generation given parameters
        The 3 points are first position, a calculated second point between, and the final position
        """
        try:
            # Normalize everything before calculating
            init_normalized_heading = normalize(init_heading)
            final_normalized_heading = normalize(final_heading)

            # Midpoint, and draw line between final and init position
            midpoint = (final_position + init_position) / 2
            line_between = final_position - init_position

            # Use line to make a perpendicular, and then calculate second point
            # that is second_point_distance away from the midpoint
            perpendicular = np.array([line_between[1], -line_between[0]])
            perpendicular = np.dot(perpendicular, init_normalized_heading) * perpendicular
            perpendicular = normalize(perpendicular)
            perpendicular = perpendicular * np.abs(1 - np.dot(init_normalized_heading, final_normalized_heading))\
                 * second_point_distance
            second_point = midpoint + perpendicular
            return [init_position, second_point, final_position]
        except:
            print("Uh oh,something went wrong with creating spline!")
            return []

    def generate_main_points(self):
        """Return 4 points primarily used in the path, given car and goal position"""
        #try:
        # Represent variables as numpy vectors for simplicity
        ball_position = np.array([self.target_pose.position.x, self.target_pose.position.y])
        bot_position = np.array([self.bot_pose.position.x, self.bot_pose.position.y])
        bot_linear_vel = np.array([self.bot_vel.linear.x, self.bot_vel.linear.y])

        # First point is certain distance ahead of car, which varies on the bot's velocity and a constant
        first_point = bot_position + self.bot_init_heading * self.DISTANCE_FROM_CAR * np.linalg.norm(bot_linear_vel)

        # Third point is a certain distance behind the ball
        third_point = ball_position - self.final_normalized_heading * self.DISTANCE_FROM_BALL

        # Last point will the ball's position itself, as the car still needs to hit it
        fourth_point = ball_position

        # Get the second point by creating a spline between the first and third
        points = self.create_spline(first_point, self.bot_init_heading, third_point, self.final_heading,\
                self.SECOND_POINT_DISTANCE)
        points.append(fourth_point)
        self.main_points = np.array(points)
        #except:
            #print("Uh oh,something went wrong with generating main points!")
            #self.main_points = np.array([])

    def follow_through_path(self):
        """
        Add point a short distance past the ball to ensure the bot follows through and return it as a pose
        """
        ball_position = np.array([self.target_pose.position.x, self.target_pose.position.y])
        point = self.final_normalized_heading * self.FOLLOW_THROUGH_DISTANCE + ball_position
        return np.array(point)
        
    
    def four_point_path(self):
        """
        Publish the main points.
        Might be useful so on the real field, we can adjust main points first before doing complicated smoothing
        """
        if (len(self.main_points) != 0):
            self.path_pub.publish(self.waypoints_from_points(self.main_points))


    def bezier_curves_path(self, smoothness):
        """
        Take the main points, and create more points by smoothing it,
        Using Bezier curves, which draws a line connecting to all the midpoints. Repeat for desired level of smoothness
        Publish these points as an array, resulting in path

        Parameters needed:
        - smoothness
            - determines how many times the bezier algorithm should be applied
            - the higher, the smoother it will be, but the more it will deviate from the original main points
        """
        # Check to make sure main points have been generated first
        if (len(self.main_points) != 0):
            points = self.main_points

            # Perform Bezier smoothing for certain amount of times
            for x in range(0, smoothness):
                temp = []
                temp.append(points[0])

                # Taking the midpoint of the current point and the next point
                for i in range(0, len(points) - 1):
                    midpoint = (points[i] + points[i + 1]) / 2
                    temp.append(midpoint)
                temp.append(points[len(points) - 1])
                points = temp

            # Convert points to poses and publish
            self.path_pub.publish(self.waypoints_from_points(points))

    def lagrange_functions_path(self):
        """
        Take the main points, and create more points bot can follow by smoothing it,
        Using Lagrange functions.
        Publish these points as an array, resulting in path
        """
        try:
            # Create dependent parameter of function
            t = np.linspace(0, len(self.main_points) - 1, self.RESOLUTION)

            # Initialize functions
            B = np.ones((len(self.main_points),len(t)))

            # Define Lagrange Interpolated Curve functions
            for i in range(0,len(self.main_points)):
                for j in range(0,len(self.main_points)):
                    if (i != j):
                        B[i] = B[i] * (t - j)/(i - j)

            # Find x and y values of main points
            x = self.main_points[:,0]
            y = self.main_points[:,1]

            # Create points of path by taking dot product of functions and main points
            path_x = np.dot(x, B)
            path_y = np.dot(y, B)
            path = np.column_stack([path_x,path_y])

            # Convert points to poses and publish
            self.path_pub.publish(self.waypoints_from_points(path))

        except:
            print("Whoops! We couldn't make a path.")

    def hermite_splines_path(self):
        """
        Take the main points, and create more points bot can follow by smoothing it,
        Using Hermite Splines.
        Publish these points as an array, resulting in path
        """
        #try:
        # Create an array of points to work with
        points = self.main_points
        points = np.vstack([np.array([self.bot_pose.position.x, self.bot_pose.position.y]),points])

        # Create parameter for our function to operate over, and divide the resolution
        # into parts for each splice. We may end up with slightly fewer points than
        # the resolution calls for... Something to look into.
        t = np.linspace(0, 1, int(self.RESOLUTION / (len(points)-1)))

        # Initialize tangent vectors
        tangents = np.zeros((len(points), 2))  # Plus 1 is because I'm starting the curve at the bot

        # constant for heading multiplier
        c = 1

        # Define tangents at midpoints
        for i in range(1, len(points) - 2):
            tangents[i] = (1 - 0.5) * (points[i + 1] - points[i - 1])
            tangents[i] = normalize(tangents[i])
            vec_1 = points[i] - points[i-1]
            vec_2 = points[i] - points[i+1]
            # Create multiplier based on the difference on the angle between points
            head_mul = None
            if np.sqrt(np.dot(vec_1,vec_1)*np.dot(vec_2,vec_2)) != 0:
                head_mul = np.arccos(np.dot(vec_1,vec_2)/(np.sqrt(np.dot(vec_1,vec_1)*np.dot(vec_2,vec_2))))
            else:
                head_mul = 1
            head_mul = (np.pi - (head_mul))
            tangents[i] = tangents[i] * head_mul**2

        # Define tangents at endpoints
        tangents[0] = self.bot_init_heading
        tangents[len(tangents) - 2] = self.final_normalized_heading
        tangents[len(tangents) -1] = self.final_normalized_heading

        # multiply tangents by constant
        tangents = tangents * c

        # Creating splines
        tees = np.vstack([t ** 3, t ** 2, t,np.ones(len(t))]) #, np.ones(len(t))], (len(t), 4))
        tees = np.transpose(tees)

        constants = np.array(([2, -2, 1, 1], [-3, 3, -2, -1], [0, 0, 1, 0], [1, 0, 0, 0]))

        # initialize paths
        path_x = np.array(())
        path_y = np.array(())

        # Create paths for off of splines
        for i in range(0, len(points)-1):
            x = np.array((points[i], points[i + 1], tangents[i], tangents[i + 1]))
            B = np.matmul(tees, constants)
            F = np.matmul(B,x)
            path_x = np.append(path_x,F[:,0])
            path_y = np.append(path_y,F[:,1])

        # Create path to use in waypoints_from_points,.
        path = np.column_stack([path_x,path_y])

        # Convert points to poses and publish
        print("hermite spline")
        self.path_pub.publish(self.waypoints_from_points(path))

        #except:
         #   print("path failed")


    def recursive_splines_path(self, angle_limit, smoothness, distance_reduction):
        """
        Take the main points, and create more points bot can follow by smoothing it,
        Using repetitive spline generation. If our points exceed angle limit, generate another spline between them
        Publish these points as an array, resulting in path

        Parameters needed:
        - angle_limit
            - Max angle between the points
            - Algorithm will repeat until angles < angle_limit, or after its iterated thru algorithm 'smoothness' times
        - smoothness
            - Max amount of times the algorithms should repeat
            - Algorithm will repeat until angles < angle_limit, or after its iterated thru algorithm 'smoothness' times
        - distance_reduction
            - When repeating algorithm and generating splines, reduce the second_point_distance with distance_reduction
            - distance_reduction * second_point_distance = new_second_point_distance
        """
        try:
            if (len(self.main_points) != 0):
                # To smooth things, we are only looking at every point except the very last point (the ball's position)
                points = [self.main_points[0], self.main_points[1], self.main_points[2]]
                distance_over_time = self.SECOND_POINT_DISTANCE / 2
                smoothed = False

                # Repeatedly create spline until we've reached max level of smoothness or it's already smooth
                for i in range(0, smoothness):
                    smoothed = True

                    # This array will keep track of our smoothed points while we loop thru our current points
                    temp = []
                    temp.append(points[0])
                    for x in range(1, len(points)):
                        # Calculate the angle between the current point and the last point
                        first_vector = self.bot_init_heading if x == 1 else points[x - 1] - points[x - 2]
                        second_vector = points[x] - points[x - 1]
                        angle = np.degrees(np.arccos(np.dot(first_vector, second_vector) / (np.linalg.norm(first_vector)\
                             * np.linalg.norm(second_vector))))

                        # If our angle is > angle_limit, create another spline between those points
                        if (not np.isnan(angle) and angle > angle_limit):
                            final_vector = points[x + 1] - points[x] if x < len(points) - 1 else self.final_heading
                            new_points = self.create_spline(points[x - 1], first_vector, points[x], final_vector,\
                                 distance_over_time)
                            distance_over_time *= distance_reduction

                            # We don't want to include the generated spline's first point, as it's the same as our current point and we are trying to smooth it
                            temp.append(new_points[1])
                            temp.append(new_points[2])
                            smoothed = False
                        elif (not np.isnan(angle)):
                            # If our angle is fine, do nothing to it
                            temp.append(points[x])

                    # Reassign our current points to the new smoothed ones
                    points = temp

                    # If we are already smoothed, don't bother looping again
                    if (smoothed):
                        break

                # Add out ball's position back
                points.append(self.main_points[3])
                self.path_pub.publish(self.waypoints_from_points(points))
        except:
            print("path failed")

def normalize(v):
    norm = np.linalg.norm(v)
    if norm == 0:
       return v
    return v / norm

if __name__ == "__main__":
    TrajectoryPlannerROS()
