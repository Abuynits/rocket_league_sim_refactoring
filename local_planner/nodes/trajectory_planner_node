#!/usr/bin/env python

"""Contains the TrajectoryPlannerROS Node.

License:
  BSD 3-Clause License
  Copyright (c) 2020, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
  1. Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
  3. Neither the name of the copyright holder nor the names of its
     contributors may be used to endorse or promote products derived from
     this software without specific prior written permission.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

from threading import Lock
import rospy 

from geometry_msgs.msg import PoseWithCovarianceStamped, PoseArray, Pose
from nav_msgs.msg import Odometry
from std_msgs.msg import Float64
import math
import numpy as np

class TrajectoryPlannerROS(object):
	"""A node to plan local car trajectories."""
	def __init__(self):
        rospy.init_node('trajectory_planner_node')
        self.lock = Lock()
        rate = rospy.Rate(30) # Hz

        # Variables
        self.ball_pose = None
        self.goal_pose = None
        self.bot_pose = None
        self.bot_vel = None
        self.bot_normalized_vel = None
        # no idea what speed will be yet
        self.MOVE_SPEED = 1.0
        self.FINAL_SPEED = 1.0
        self.final_vector = None
        self.final_normalized_vector = None
        self.main_points = []
        # These variables act as parameters to generate a path
        self.DISTANCE_FROM_CAR = 1
        self.DISTANCE_FROM_BALL = 1
        self.SECOND_POINT_DISTANCE = 1
        # This variable determines the number of points published to the waypoint controller
        self.RESOLUTION = 20

		# Publishers
        self.path_pub = rospy.Publisher("bot_path", PoseArray, queue_size=1)
        self.final_speed_pub = rospy.Publisher("bot_final_speed", Float64, queue_size=1)

		# Subscribers
        rospy.Subscriber("ball_pose", PoseWithCovarianceStamped, self.ball_pose_cb)
        rospy.Subscriber("goal_pose", PoseWithCovarianceStamped, self.goal_pose_cb)
        rospy.Subscriber("bot_odom", Odometry, self.bot_odom_cb)

        while not rospy.is_shutdown():
            self.loop_once()
            try:
                rate.sleep()
            except rospy.ROSInterruptException:
                pass

	def loop_once(self):
		"""Main loop."""
		self.lock.acquire()
		# Loop code
        self.generate_points()
        self.create_path_1()   # could also be 2
        self.publish_final_speed()
		self.lock.release()

    def ball_pose_cb(self, ball_pose_message):
        """Callback for getting ball pose"""
        self.ball_pose = ball_pose_message.data

    def goal_pose_cb(self, goal_pose_message):
        """Callback for getting goal pose"""
        self.goal_pose = goal_pose_message.data

    def bot_odom_cb(self, bot_odom_message):
        """ Callback for bot pose and velocity"""
        # Pose represents robot's position and orientation
        self.bot_pose = bot_odom_message.data.pose
        # Bot velocity indicates the bot's heading through a vector
        self.bot_vel = bot_odom_message.data.twist.twist
        # Normalize bot velocity vector for future calculations
        linear_vel = numpy.array([self.bot_vel.linear.x, self.bot_vel.linear.y])
        mag = np.linalg.norm(linear_vel)
        self.bot_normalized_vel = linear_vel / mag

    def calculate_final_vector(self):
        """Calculate final vector (final heading)"""
        # Final vector is simply the goal's position minus the ball's position
        self.final_vector = np.array([self.goal_pose.position.x - self.ball_pose.position.x, self.goal_pose.position.y - self.ball_pose.position.y])
        # Normalize the vector for future calculations
        mag = np.linalg.norm(self.final_vector)
        self.final_normalized_vector = self.final_vector / mag

    def publish_final_speed(self):
        """Calculates and publishes the final velocity. Will be set as a constant for now."""
        final_velocity = self.FINAL_SPEED

        # Convert final velocity to a float64 and publish
        new_float = Float64()
        new_float = final_velocity
        self.final_speed_pub.publish(new_float)

    def generate_points(self):
        """Generate 4 points using spline generation"""
        if (self.final_heading !== None) and (self.bot_vel != None):
            # Clear previous points to generate new ones using updated subscriber info
            self.main_points = []
            # Represent variables as numpy vectors for simplicity
            ball_position = np.array([self.ball_pose.position.x, self.ball_pose.position.y])
            bot_position = np.array([self.bot_pose.position.x, self.bot_pose.position.y])
            bot_linear_vel = np.array([self.bot_vel.linear.x, self.bot_vel.linear.y])
            
            # First point is simply a certain distance ahead of car, which varies on the bot's velocity and a constant
            first_point = bot_position + bot_linear_vel * self.DISTANCE_FROM_CAR
            # Third point is a certain distance behind the ball
            third_point = ball_position - self.final_normalized_vector * self.DISTANCE_FROM_BALL
            # the fourth point will the ball's position itself
            fourth_point = ball_position

            # Second point is calculated by finding midpoint between first and third point
            midpoint = (third_point + first_point) / 2
            # and using the line perpendicular to the line between first and third point
            perpendicular = third_point - first_point
            perpendicular = np.array([perpendicular[1], -perpendicular[0]])
            # Figure out what direction this perpendicular line needs to go by projecting bot heading onto this perpendicular. Normalize it
            perpendicular = np.dot(perpendicular, self.bot_normalized_vel) * perpendicular
            perpendicular = perpendicular / np.linalg.norm(perpendicular)
            # Make the magnitude (distance from midpoint) vary by error of bot heading and final heading, and constant
            perpendicular = perpendicular * np.abs(1 - np.dot(self.bot_normalized_vel, self.final_normalized_vector)) * self.SECOND_POINT_DISTANCE
            second_point = midpoint + perpendicular
            
            self.main_points = np.array([first_point, second_point, third_point,fourth_point])


    def create_path_1(self):
        """
        Take the main points, and create more points by smoothing it,
        Using Bezier curves, which draws a line connecting to all the midpoints. Repeat for desired level of smoothness
        Publish these points as an array, resulting in path
        """
        points = self.main_points
        # Perform Bezier smoothing for certain amount of times
        for x in range(0, 3):
            temp = []
            temp.append(points[0])
            # Taking the midpoint of the current point and the next point
            for i in range(0, len(points) - 1):
                midpoint = (points[i] + points[i + 1]) / 2
                temp.append(midpoint)
            temp.append(points[len(points) - 1])
            points = temp
        
        # Convert points to poses and publish
        pose_array_msg = PoseArray()
        pose_array_msg.poses = []
        for x in range(len(points)):
            new_pose = Pose()
            new_pose.position.x = points[x][0]
            new_pose.position.y = points[x][1]
            pose_array_msg.poses.append(new_pose)
        self.path_pub.publish(pose_array_msg)

    def create_path_2(self):
        """
        Take the main points, and create more points bot can follow by smoothing it,
        either via Bezier curves, or Legrange functions.
        Publish these points as an array, resulting in path
        """
        # Check to make sure main points have been generated first
        if (self.main_points != None):

            # Create dependent parameter of function
            t = np.linspace(0, len(self.main_points) - 1, self.RESOLUTION)

            # Initialize functions
            B = np.ones(len(self.main_points))

            # Define Lagrange Interpolated Curve functions
            for i in range(0,len(self.main_points)):
                for j in range(0,len(self.main_points)):
                    if (i != j):
                        B[i] = B[i] * (t - j)/(i - j)

            # Find x and y values of main points
            x = self.main_points[:,0]
            y = self.main_points[:,1]

            # Create points of path by taking dot product of functions and main points
            path_x = np.dot(x, B)
            path_y = np.dot(y, B)

            # Convert points to poses and publish
            pose_array_msg = PoseArray()
            pose_array_msg.poses = []
            for i in range(0,len(path_x)):
                new_pose = Pose()
                new_pose.position.x = path_x[i]
                new_pose.position.y = path_y[i]
                pose_array_msg.poses.append(new_pose)
            self.path_pub.publish(pose_array_msg)



if __name__ == "__main__":
	TrajectoryPlannerROS()