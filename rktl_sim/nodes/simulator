#!/usr/bin/env python3
"""Node to run the simulator with ROS bindings.
License:
  BSD 3-Clause License
  Copyright (c) 2020, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
"""

# 3rd party modules
import random
from geometry_msgs.msg import PoseWithCovarianceStamped
from nav_msgs.msg import Odometry
import os
import rospy
from std_srvs.srv import Empty, EmptyResponse
from threading import Lock
from enum import Enum

# Local library
import simulator
from rktl_sim.srv import CreateCar, CreateCarResponse, DeleteCar, DeleteCarResponse
from rktl_msgs.msg import MatchStatus, ControlCommand, ControlEffort


class SimulatorMode(Enum):
    # NOTE: two types of models
    # ideal: no sensor noise, realistic: simulate sensor noise
    IDEAL = 1
    REALISTIC = 2


class Simulator(object):
    """ROS wrapper for the simulator.
    Get the mode in which run: ideal vs reaslistics
    Get the parameters at which run sim: (rate, frame, timeout)
    Set the spawn bounds
    Create the ball (position and speed)
    Loops over all cars for which it has a config, then out of each one: creates a tuple of:
    - Car id
    - Car pose pubs
    - Car odom pubs
    - Car effort subs
    - Car cmd subs

    simulator setup:
        create simp object from sim.py: param: props, urdf_paths, spawn_bounds, render_enabled
        setup sensor noise:
            get the ~sensor_noise param
        if sensor noise not defined and in REALISTIC mode
        - add noise to the ball
        - add noise to the car
        create the ball object: init the position and the speed
        sim.create_ball, param: 'ball', init_pose,init_speed, ball_noise

        if REALISTIC:
        ball_pose_pub publisher: /ball/pose_sync_early
        ball_odom_pub publisher: /ball/odom_truth
        if IDEAL:
        ball_odom_pub: /ball/odom

    Initialize the ball object finding the parameter from ~ball/init_pose or init_speed (depend on whether using realistic or ideal model)
    Init the ball odometry depending on whether we are using a realistic model or not


    After initializing everything above,
    Loop while rospy is not shutdown

    """

    class InvalidRospyParam(Exception):

        """exception when using invalid arguement"""
        pass

    def __init__(self):
        # create variables for the functions that might initialize them
        # TODO: can potentially specify them as return values
        self.timeout = None
        self.frame_id = None
        self.mode = None
        self.ball_odom_pub = None
        self.ball_pose_pub = None
        self.car_cmd_subs = None
        self.car_effort_subs = None
        self.car_odom_pubs = None
        self.car_pose_pubs = None
        self.car_ids = None
        self.car_cmd = None
        self.car_noise = None

        rospy.init_node('simulator')
        # init the simulator and the sim time
        rate, render_enabled = self.init_sim_environment()
        # Setup bounds for spawning car and ball
        spawn_bounds = self.get_spawn_bounds()

        urdf_paths = rospy.get_param('~urdf')
        for path in urdf_paths.values():
            self.check_urdf(path)

        # Setup simulator properties
        props = {
            'engine': rospy.get_param('~engine', None),
            'dynamics': rospy.get_param('~dynamics', None),
        }

        # Creating physics simulator
        self.sim = simulator.Sim(props, urdf_paths, spawn_bounds, render_enabled)

        # Setting sensor noise
        car_noise, ball_noise = self.set_sensor_noise()
        # TODO: not know if need to split up init func
        # want to keep sourcing of param in all location- want to see all of hte variables and pass it to gen ball
        # want to add where source param and pass to generate ball function as paramters vs self. assignment
        # publishers and subscribers: nice to see all of them there in the init function
        # hard to avoid breaking it down
        # Creating the ball
        self.generate_ball(ball_noise)
        # generate car properties
        self.generate_car_properties(car_noise)

        # create a list of car properties for each potential car that there could be

        # Node data
        self.cmd_lock = Lock()
        self.reset_lock = Lock()
        self.last_time = None

        # Publishers
        self.status_pub = rospy.Publisher(
            'match_status', MatchStatus, queue_size=1)

        # Services
        rospy.Service('sim_reset', Empty, self.reset_cb)
        rospy.Service('sim_create_car', CreateCar, self.create_car_cb)
        rospy.Service('sim_delete_car', DeleteCar, self.delete_car_cb)

        while not rospy.is_shutdown():
            self.loop_once()
            try:
                rate.sleep()
            except rospy.ROSInterruptException:
                pass

    def check_urdf(self, param):
        """
        overview: Checks whether you ahvea valid pybullet url for information
        if not, wait for the file to build in .5 seconds
        Validates that a URDF exists, then returns path
        """
        if param is None:
            rospy.signal_shutdown('no urdf path set for "{}"'.format(param))

        i = 0
        while not os.path.isfile(param) and i < 5:
            rospy.sleep(0.1)  # Wait for xacro build
            i += 1

        if not os.path.isfile(param):
            rospy.signal_shutdown(
                'no urdf file exists at path {}'.format(param))

    # TODO: how do effort_cb and cmd_cb interact?

    def effort_cb(self, effort_msg, car_id):
        """
        Sets a car's effort (overwrites commands)
        Overrides the cmd_cb: calls the car command with the throttle and steering
        TODO: during which state is it called with
        """
        self.cmd_lock.acquire()
        self.sim.set_car_command(car_id,
                                 (effort_msg.throttle, effort_msg.steering))
        self.cmd_lock.release()

    def cmd_cb(self, cmd_msg, car_id):
        """
        Overrides the effirt_cd: calls the car
        Command with the velocity and the curvature
        Sets a car's command (overwrites efforts)
        """
        self.cmd_lock.acquire()
        self.sim.set_car_command(car_id,
                                 (cmd_msg.velocity, cmd_msg.curvature))
        self.cmd_lock.release()

    def create_car_cb(self, req):
        """
        Add new car to the simulator
        Checks if resetting to random position:
        - if not, set it to default
        - if so, will be reset later in the sim.create_car function

        Get the car id,
        Subscribe:
        - effort cb: args: car_id
        - command cb: args: car_id
        If realistic mode:
        - Publish to the pose sync early (with car id)
        - Publish to the odometry truth (with car id)
        If ideal mode:
        - Publish to the odometry (with car id)
        """
        self.reset_lock.acquire()
        if req.name in self.car_ids:
            return CreateCarResponse(False)

        init_pose = None
        if req.reset_to_random_pose is False:
            init_pose = {
                "pos": [req.init_pos.x,
                        req.init_pos.y,
                        req.init_pos.z],
                "orient": [0.0, 0.0, req.init_yaw],
            }

        self.car_ids[req.name] = self.sim.create_car(
            'car', init_pose, noise=self.car_noise, props=self.car_properties)

        car_id = self.car_ids[req.name]
        self.car_effort_subs[req.name] = rospy.Subscriber(
            f'/cars/{req.name}/effort', ControlEffort,
            self.effort_cb, callback_args=car_id)
        self.car_cmd_subs[req.name] = rospy.Subscriber(
            f'/cars/{req.name}/command', ControlCommand,
            self.cmd_cb, callback_args=car_id)

        if self.mode == SimulatorMode.REALISTIC:
            self.car_pose_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/pose_sync_early',
                PoseWithCovarianceStamped, queue_size=1)
            self.car_odom_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/odom_truth', Odometry, queue_size=1)
        elif self.mode == SimulatorMode.IDEAL:
            self.car_odom_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/odom', Odometry, queue_size=1)

        self.reset_lock.release()
        return CreateCarResponse(True)

    def delete_car_cb(self, req):
        """
        Remove car from the simulator
        Delete the effort,cmd subs (check if they exist first)
        delete the odom, pose publishers (check if they exist first)
        Delete cars body from pybullet by called sim.delete_car
        """
        self.reset_lock.acquire()
        if req.name not in self.car_ids:
            return DeleteCarResponse(False)

        # Delete all related pubs and subs
        if req.name in self.car_effort_subs:
            self.car_effort_subs[req.name].unregister()
            del self.car_effort_subs[req.name]
        if req.name in self.car_cmd_subs:
            self.car_cmd_subs[req.name].unregister()
            del self.car_cmd_subs[req.name]
        if req.name in self.car_odom_pubs:
            self.car_odom_pubs[req.name].unregister()
            del self.car_odom_pubs[req.name]
        if req.name in self.car_pose_pubs:
            self.car_pose_pubs[req.name].unregister()
            del self.car_pose_pubs[req.name]

        # Delete the car's body from pybullet
        res = self.sim.delete_car(self.car_ids[req.name])
        del self.car_ids[req.name]

        self.reset_lock.release()
        return DeleteCarResponse(res)

    def reset_cb(self):
        """
        Resets the simulator
        Reset the sim.py for each car
        Rest the time
        Reset the car_cmd
        reset the simulator parameters and the sim class itself
        @return: nothing broke response
        """
        # TODO: want to give lest work with generating car properties
        # want to break down into even more functions:
        # have a seperate function for deleting the old cars, generating car properties, and making new ones
        # their purpose: calling all of the funcitons to get range and get new parameters from range from each path
        # store that data somewhere int he class
        # clall another function to reset the car htat passes on that info to make sure that its updated
        # create new cars with the newly created properties

        # OTHER NOTES:
        # parametrsr loaded form ros param server: init value read from config: bc collecting data from paths,
        # can update them real time
        # if wanted just range over tiem and increasedd the range as we train -we can do : can publish new values to the parameters
        # each time call reset: update with new knowledge and change how do domain randomizaiton
        # think of ways to ad more paramters and make more adaptable

        # self.configure_dynamics(self.plnae_id)- avoid generating a new data file: outsource all of that to doing computation in ros
        # instead of rereading the paramters and storing them: can have function that reads param again if change max and min
        # do the computation in the simulator node
        # then pass that computation to the configure dynamics file

        # other: adding functionality to autonomy pachage
        # train_rocket_league.py;
        # waht about rocket_league_interface: they are pulling in paramters there (under rktl_autonomy)
        # want to add functionality to set ranges between runs: after each run: want to increase the range of param by 0.1
        # as we conifugre that: there is another function :they use rospy.getparam: there is a setparam function: use between runs
        # for autonomy pacakge: want to do: might not be immediately aware what param available to update bc use sim.configure file
        # can add apram to simulator.yaml: can include a publish param that we are currently using: set out list
        # and process them: "sim configurable params' has list of apram names used by the simulator
        # autonomy can check that parameter and find all of the things it is allwoed to change
        # that was it iss independent of the simulator that is runnign :in the future can add more params and understand they exist
        # or if they want to take away params
        # bc this is one time thing: makes it to be a list in sim.yaml file: whatever devs of sim nodes know to chagne

        # as part of autonomy side: oportunity to explore literature online
        # many techniques for how do; want to account for soeme of them and think of what features add to support it

        # good skill pull up brand new project and understand it

        self.reset_lock.acquire()

        # TODO: need to pass key variables to the rest function located in the sim class
        spawn_bounds = self.get_spawn_bounds()

        self.generate_car_properties(self.car_noise)

        self.sim.reset(spawn_bounds)
        self.car_cmd = (0.0, 0.0)
        self.last_time = None
        self.reset_lock.release()
        return EmptyResponse()

    def loop_once(self):
        """
        Pause the time
        Step the simulation once step
        Update the match status: if either team scored, show the winner, if not, continue the match

        If the simulation mode is realistic:
        - Write the ball positing and orientation variables (pub)
        - Write each cars position and orientation variables (pub)
        For all modes (ideal and realistic):
        Move the ball forward: get its position, and publish it (via Odometry() func)
        For each car, move it forward, get its position and publish it (via Odometry() func)
        Resume the time
        """
        self.reset_lock.acquire()
        now = rospy.Time.now()
        if self.last_time is not None and self.last_time != now:
            # Iterate sim one step
            delta_t = (now - self.last_time).to_sec()
            self.sim.step(delta_t)

            # Publish game status
            status = MatchStatus()
            if self.sim.scored:
                if self.sim.winner == "A":
                    status.status = MatchStatus.VICTORY_TEAM_A
                elif self.sim.winner == "B":
                    status.status = MatchStatus.VICTORY_TEAM_B
            else:
                status.status = MatchStatus.ONGOING
            self.status_pub.publish(status)

            # Publish pose and odometry data
            if self.mode == SimulatorMode.REALISTIC:
                ball_msg = PoseWithCovarianceStamped()
                ball_msg.header.stamp = now
                ball_msg.header.frame_id = self.frame_id
                ball_pos, ball_quat = self.sim.get_ball_pose(add_noise=True)
                ball_msg.pose.pose.position.x = ball_pos[0]
                ball_msg.pose.pose.position.y = ball_pos[1]
                ball_msg.pose.pose.position.z = ball_pos[2]
                ball_msg.pose.pose.orientation.x = ball_quat[0]
                ball_msg.pose.pose.orientation.y = ball_quat[1]
                ball_msg.pose.pose.orientation.z = ball_quat[2]
                ball_msg.pose.pose.orientation.w = ball_quat[3]
                self.ball_pose_pub.publish(ball_msg)

                for car_name in self.car_ids:
                    car_msg = PoseWithCovarianceStamped()
                    car_msg.header.stamp = now
                    car_msg.header.frame_id = self.frame_id
                    car_pos, car_quat = self.sim.get_car_pose(
                        self.car_ids[car_name], add_noise=True)
                    car_msg.pose.pose.position.x = car_pos[0]
                    car_msg.pose.pose.position.y = car_pos[1]
                    car_msg.pose.pose.position.z = car_pos[2]
                    car_msg.pose.pose.orientation.x = car_quat[0]
                    car_msg.pose.pose.orientation.y = car_quat[1]
                    car_msg.pose.pose.orientation.z = car_quat[2]
                    car_msg.pose.pose.orientation.w = car_quat[3]
                    self.car_pose_pubs[car_name].publish(car_msg)
            # TODO: why not in an else block: publish data twice no?
            ball_msg = Odometry()
            ball_msg.header.stamp = now
            ball_msg.header.frame_id = self.frame_id
            ball_pos, ball_quat = self.sim.get_ball_pose()
            ball_msg.pose.pose.position.x = ball_pos[0]
            ball_msg.pose.pose.position.y = ball_pos[1]
            ball_msg.pose.pose.position.z = ball_pos[2]
            ball_msg.pose.pose.orientation.x = ball_quat[0]
            ball_msg.pose.pose.orientation.y = ball_quat[1]
            ball_msg.pose.pose.orientation.z = ball_quat[2]
            ball_msg.pose.pose.orientation.w = ball_quat[3]
            ball_linear, ball_angular = self.sim.get_ball_velocity()
            ball_msg.twist.twist.linear.x = ball_linear[0]
            ball_msg.twist.twist.linear.y = ball_linear[1]
            ball_msg.twist.twist.linear.z = ball_linear[2]
            ball_msg.twist.twist.angular.x = ball_angular[0]
            ball_msg.twist.twist.angular.y = ball_angular[1]
            ball_msg.twist.twist.angular.z = ball_angular[2]
            self.ball_odom_pub.publish(ball_msg)

            for car_name in self.car_ids:
                car_msg = Odometry()
                car_msg.header.stamp = now
                car_msg.header.frame_id = self.frame_id
                car_pos, car_quat = self.sim.get_car_pose(
                    self.car_ids[car_name])
                car_msg.pose.pose.position.x = car_pos[0]
                car_msg.pose.pose.position.y = car_pos[1]
                car_msg.pose.pose.position.z = car_pos[2]
                car_msg.pose.pose.orientation.x = car_quat[0]
                car_msg.pose.pose.orientation.y = car_quat[1]
                car_msg.pose.pose.orientation.z = car_quat[2]
                car_msg.pose.pose.orientation.w = car_quat[3]
                car_linear, car_angular = self.sim.get_car_velocity(
                    self.car_ids[car_name])
                car_msg.twist.twist.linear.x = car_linear[0]
                car_msg.twist.twist.linear.y = car_linear[1]
                car_msg.twist.twist.linear.z = car_linear[2]
                car_msg.twist.twist.angular.x = car_angular[0]
                car_msg.twist.twist.angular.y = car_angular[1]
                car_msg.twist.twist.angular.z = car_angular[2]
                self.car_odom_pubs[car_name].publish(car_msg)

        self.last_time = now
        self.reset_lock.release()

    def get_rospy_param(self, path):
        """
        create a parameter from the path variable
        check if the variable exist in rospy. if not, throw error
        check if its a dict, if so, check if have min and max, if so, generate random param
        if not, throw error

        if not dict, then check if its a value and return it. if not, throw an errir
        @param path:
        @return:
        """
        if not rospy.get_param(path):
            raise self.InvalidRospyParam(path)
        else:
            type_rospy = type(rospy.get_param(path))

            if type_rospy == dict:
                min_param = rospy.get_param(f'${path}/min')
                max_param = rospy.get_param(f'${path}/max')

                if not max_param:
                    raise self.InvalidRospyParam(f'${path}/max')
                if not min_param:
                    raise self.InvalidRospyParam(f'${path}/min')

                return random.uniform(min_param, max_param)

            elif type_rospy == float or type_rospy == int:
                return rospy.get_param(path)
        raise self.InvalidRospyParam(path)

    def get_spawn_bounds(self):
        """
        randomly generates the spawn bounds if we specify to generate random ones
        @return: the spawn bound array
        """
        # Setting up field
        fw = self.get_rospy_param("/field/width")
        fl = self.get_rospy_param("/field/length")
        spawn_height = rospy.get_param('~spawn_height', 0.06)
        wt = rospy.get_param('/field/wall_thickness')

        spawn_bounds = [[-(fl / 2) + (2 * wt), (fl / 2) - (2 * wt)],
                        [-(fw / 2) + (2 * wt), (fw / 2) - (2 * wt)],
                        [spawn_height, spawn_height]]
        return spawn_bounds

    def generate_car_properties(self, car_noise):
        """
        Set the car parameters based on those provided in the rospy directory (the properties of the car itself: length, max_speed, throttle, steering, simulate effort, etc)
        - generates random max speed and steering throw by calling other functions
        - used to generate these properties for each car
        Create a list for each car depending on its properties:
            Car id
            Car pose publisher
            Car odom publisher
            Car effort subscribers
            Car command subscribers
        Publisher:
            match_status
        Service:
            Sim_reset
            Sim_create_car
            sim_delete_Car
        @param car_noise:
        """
        # general paramters that are the same for every single car
        self.car_properties = {}
        self.car_properties['length'] = rospy.get_param('/cars/length')

        self.car_properties['max_speed'] = self.get_rospy_param("/cars/throttle/max_speed")
        self.car_properties['steering_throw'] = self.get_rospy_param("/cars/throttle/max_steering_throw")

        self.car_properties['throttle_tau'] = rospy.get_param('/cars/throttle/tau')
        self.car_properties['steering_rate'] = rospy.get_param('/cars/steering/rate')
        self.car_properties['simulate_effort'] = (self.mode == SimulatorMode.REALISTIC)


    def generate_cars(self):
        car_configs = rospy.get_param('~cars', [])
        self.car_ids = {}
        self.car_pose_pubs = {}
        self.car_odom_pubs = {}
        self.car_effort_subs = {}
        self.car_cmd_subs = {}

        for car_config in car_configs:
            init_pose = None
            if 'init_pose' in car_config:
                init_pose = car_config['init_pose']

            if 'name' not in car_config:
                rospy.signal_shutdown('no "name" set for car config in sim')
            car_name = car_config['name']
            if 'randomize_pose' in car_config:
                init_pose = None

            self.car_ids[car_name] = self.sim.create_car(
                'car', init_pose=init_pose, noise=self.car_noise, car_props=self.car_properties)

            car_id = self.car_ids[car_name]
            self.car_effort_subs[car_name] = rospy.Subscriber(
                f'/cars/{car_name}/effort', ControlEffort,
                self.effort_cb, callback_args=car_id)
            self.car_cmd_subs[car_name] = rospy.Subscriber(
                f'/cars/{car_name}/command', ControlCommand,
                self.cmd_cb, callback_args=car_id)

            if self.mode == SimulatorMode.REALISTIC:
                self.car_pose_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/pose_sync_early',
                    PoseWithCovarianceStamped, queue_size=1)
                self.car_odom_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/odom_truth', Odometry, queue_size=1)
            elif self.mode == SimulatorMode.IDEAL:
                self.car_odom_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/odom', Odometry, queue_size=1)

    def set_sensor_noise(self):
        """
        adds the sensor noise for the car and for the ball
        @return: the sensor noises
        """
        sensor_noise = rospy.get_param('~sensor_noise', None)
        ball_noise = None
        car_noise = None
        if sensor_noise is not None and self.mode == SimulatorMode.REALISTIC:
            ball_noise = sensor_noise.get('ball', None)
            car_noise = sensor_noise.get('car', None)
        self.car_noise = car_noise
        return car_noise, ball_noise

    def generate_ball(self, ball_noise):
        """
        check if we want to randomize the ball properties (ball pos and ball vel)
        if we want to randomize, then we will do so in the sim.py
        @param ball_noise: the ball noise that is used to generate the ball object
        """
        # TODO: need to potentially chagne the init pose here
        ball_init_pose = rospy.get_param('~ball/init_pose', None)
        ball_init_speed = rospy.get_param('~ball/init_speed', None)

        self.sim.create_ball('ball', init_pose=ball_init_pose,
                             init_speed=ball_init_speed, noise=ball_noise)
        if self.mode == SimulatorMode.REALISTIC:
            self.ball_pose_pub = rospy.Publisher('/ball/pose_sync_early',
                                                 PoseWithCovarianceStamped, queue_size=1)
            self.ball_odom_pub = rospy.Publisher('/ball/odom_truth',
                                                 Odometry, queue_size=1)
        elif self.mode == SimulatorMode.IDEAL:
            self.ball_odom_pub = rospy.Publisher('/ball/odom',
                                                 Odometry, queue_size=1)

    def init_sim_environment(self):
        """
        initialize the mode of the simulator
        initialize simulator time
        @return: the rate at which the simulator runs, and whether the render is enabled
        """
        # the different nodes determine whether their is noise or not
        mode = rospy.get_param('~mode')
        if mode == 'ideal':
            self.mode = SimulatorMode.IDEAL
        elif mode == 'realistic':
            self.mode = SimulatorMode.REALISTIC
        else:
            rospy.signal_shutdown('unknown sim mode set "{}"'.format(mode))

        # set the engine environemnt
        render_enabled = rospy.get_param('~render', False)
        rate = rospy.Rate(rospy.get_param('~rate', 30))
        self.frame_id = rospy.get_param('~frame_id', 'map')
        self.timeout = rospy.get_param('~timeout', 10)
        return rate, render_enabled


"""the main function: call the simulator to init the loop and create objects"""
if __name__ == "__main__":
    Simulator()
