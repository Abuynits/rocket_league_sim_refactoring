#!/usr/bin/env python3
"""Node to run the simulator with ROS bindings.
License:
  BSD 3-Clause License
  Copyright (c) 2020, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
"""

# 3rd party modules
import random
from geometry_msgs.msg import PoseWithCovarianceStamped
from nav_msgs.msg import Odometry
import os
import rospy
from std_srvs.srv import Empty, EmptyResponse
from threading import Lock
from enum import Enum

# Local library
import simulator
from rktl_sim.srv import CreateCar, CreateCarResponse, DeleteCar, DeleteCarResponse
from rktl_msgs.msg import MatchStatus, ControlCommand, ControlEffort


class SimulatorMode(Enum):
    # NOTE: two types of models
    # ideal: no sensor noise, realistic: simulate sensor noise
    IDEAL = 1
    REALISTIC = 2


class Simulator(object):
    """ROS wrapper for the simulator.
    Get the mode in which run: ideal vs reaslistics
    Get the parameters at which run sim: (rate, frame, timeout)
    Set the spawn bounds
    Create the ball (position and speed)
    Loops over all cars for which it has a config, then out of each one: creates a tuple of:
    - Car id
    - Car pose pubs
    - Car odom pubs
    - Car effort subs
    - Car cmd subs

    simulator setup:
        create simp object from sim.py: param: props, urdf_paths, spawn_bounds, render_enabled
        setup sensor noise:
            get the ~sensor_noise param
        if sensor noise not defined and in REALISTIC mode
        - add noise to the ball
        - add noise to the car
        create the ball object: init the position and the speed
        sim.create_ball, param: 'ball', init_pose,init_speed, ball_noise

        if REALISTIC:
        ball_pose_pub publisher: /ball/pose_sync_early
        ball_odom_pub publisher: /ball/odom_truth
        if IDEAL:
        ball_odom_pub: /ball/odom

    Initialize the ball object finding the parameter from ~ball/init_pose or init_speed
    (depend on whether using realistic or ideal model)
    Init the ball odometry depending on whether we are using a realistic model or not


    After initializing everything above,
    Loop while rospy is not shutdown

    """

    def __init__(self):
        """intializes the simulator param such as time, framrate, car properties, sim mode etc"""

        rospy.init_node('simulator')
        mode = self.get_sim_param('~mode')
        if mode == 'ideal':
            self.mode = SimulatorMode.IDEAL
        elif mode == 'realistic':
            self.mode = SimulatorMode.REALISTIC
        else:
            rospy.signal_shutdown('unknown sim mode set "{}"'.format(mode))

        # set the engine environment
        render_enabled = self.get_sim_param('~render', secondParam=False)
        # the rate at which we will run the simulator
        rate = rospy.Rate(self.get_sim_param('~rate', secondParam=30))
        # the frame id of the specific run
        self.frame_id = self.get_sim_param('~frame_id', secondParam='map')
        # the timeout associated with a pause
        self.timeout = self.get_sim_param('~timeout', secondParam=10)

        # Setup bounds for spawning car and ball
        spawn_bounds = self.get_spawn_bounds()

        # setup urdf file paths: unversial way to describe kinematics and dynamics of robots
        urdf_paths = self.get_sim_param('~urdf')
        for path in urdf_paths.values():
            self.check_urdf(path)

        # Setup simulator properties
        props = {
            'engine': self.get_sim_param('~engine', secondParam=None),
            'dynamics': self.get_sim_param('~dynamics', secondParam=None),
        }

        # Creating physics simulator
        self.sim = simulator.Sim(props, urdf_paths, spawn_bounds, render_enabled)

        # Setting sensor noise
        sensor_noise = rospy.get_sim_param('~sensor_noise', secondParam=None)
        # the different nodes determine whether there is noise or not
        self.ball_noise = None
        self.car_noise = None
        if sensor_noise is not None and self.mode == SimulatorMode.REALISTIC:
            self.ball_noise = sensor_noise.get('ball', None)
            self.car_noise = sensor_noise.get('car', None)
        # Creating the ball
        # check if we want to randomize the ball properties (ball pos and ball vel)
        # if we want to randomize, then we will do so in the sim.py

        self.ball_pose_pub, self.ball_odom_pub = None, None
        ball_init_pose = rospy.get_sim_param('~ball/init_pose')
        ball_init_speed = rospy.get_sim_param('~ball/init_speed')

        self.sim.create_ball('ball', init_pose=ball_init_pose,
                             init_speed=ball_init_speed, noise=self.ball_noise)
        if self.mode == SimulatorMode.REALISTIC:
            self.ball_pose_pub = rospy.Publisher('/ball/pose_sync_early',
                                                 PoseWithCovarianceStamped, queue_size=1)
            self.ball_odom_pub = rospy.Publisher('/ball/odom_truth',
                                                 Odometry, queue_size=1)
        elif self.mode == SimulatorMode.IDEAL:
            self.ball_odom_pub = rospy.Publisher('/ball/odom',
                                                 Odometry, queue_size=1)

        # generate car properties
        self.car_properties = self.generate_car_properties()

        # important variables for the car publishers, subscribers, and so on
        self.car_ids = {}
        self.car_pose_pubs = {}
        self.car_odom_pubs = {}
        self.car_effort_subs = {}
        self.car_cmd_subs = {}
        # generates all of the cars
        self.generate_all_cars()

        # Node data
        self.cmd_lock = Lock()
        self.reset_lock = Lock()
        self.last_time = None

        # Publishers
        self.status_pub = rospy.Publisher(
            'match_status', MatchStatus, queue_size=1)

        # Services
        rospy.Service('sim_reset', Empty, self.reset_cb)
        rospy.Service('sim_create_car', CreateCar, self.create_car_cb)
        rospy.Service('sim_delete_car', DeleteCar, self.delete_car_cb)

        while not rospy.is_shutdown():
            self.loop_once()
            try:
                rate.sleep()
            except rospy.ROSInterruptException:
                pass

    def check_urdf(self, param):
        """
        Validates that a URDF exists, then returns path
        @param param: the path to the URDF
        """
        if param is None:
            rospy.signal_shutdown('no urdf path set for "{}"'.format(param))

        i = 0
        while not os.path.isfile(param) and i < 5:
            rospy.sleep(0.1)  # Wait for xacro build
            i += 1

        if not os.path.isfile(param):
            rospy.signal_shutdown(
                'no urdf file exists at path {}'.format(param))

    def effort_cb(self, effort_msg, car_id):
        """Sets a car's effort (overwrites commands)"""
        self.cmd_lock.acquire()
        self.sim.set_car_command(car_id,
                                 (effort_msg.throttle, effort_msg.steering))
        self.cmd_lock.release()

    def cmd_cb(self, cmd_msg, car_id):
        """Sets a car's command with the velocity and curvature"""
        self.cmd_lock.acquire()
        self.sim.set_car_command(car_id,
                                 (cmd_msg.velocity, cmd_msg.curvature))
        self.cmd_lock.release()

    def create_car_cb(self, req):
        """Add new car to the simulator"""
        self.reset_lock.acquire()
        if req.name in self.car_ids:
            return CreateCarResponse(False)

        init_pose = None
        # Checks if resetting to random position:
        # - if not, set it to default
        # - if so, will be reset later in the sim.create_car function
        if req.reset_to_random_pose is False:
            init_pose = {
                "pos": [req.init_pos.x,
                        req.init_pos.y,
                        req.init_pos.z],
                "orient": [0.0, 0.0, req.init_yaw],
            }

        self.car_ids[req.name] = self.sim.create_car(
            'car', init_pose, noise=self.car_noise, props=self.car_properties)
        # Subscribe:
        # effort cb: args: car_id
        # command cb: args: car_id
        car_id = self.car_ids[req.name]
        self.car_effort_subs[req.name] = rospy.Subscriber(
            f'/cars/{req.name}/effort', ControlEffort,
            self.effort_cb, callback_args=car_id)
        self.car_cmd_subs[req.name] = rospy.Subscriber(
            f'/cars/{req.name}/command', ControlCommand,
            self.cmd_cb, callback_args=car_id)

        if self.mode == SimulatorMode.REALISTIC:
            # Publish to the pose sync early (with car id)
            # Publish to the odometry truth (with car id)
            self.car_pose_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/pose_sync_early',
                PoseWithCovarianceStamped, queue_size=1)
            self.car_odom_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/odom_truth', Odometry, queue_size=1)
        elif self.mode == SimulatorMode.IDEAL:
            # Publish to the odometry (with car id)
            self.car_odom_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/odom', Odometry, queue_size=1)

        self.reset_lock.release()
        return CreateCarResponse(True)

    def delete_car_cb(self, req):
        """Remove car from the simulator"""
        self.reset_lock.acquire()
        if req.name not in self.car_ids:
            return DeleteCarResponse(False)

        # Delete the effort,cmd subs (check if they exist first)
        if req.name in self.car_effort_subs:
            self.car_effort_subs[req.name].unregister()
            del self.car_effort_subs[req.name]
        if req.name in self.car_cmd_subs:
            self.car_cmd_subs[req.name].unregister()
            del self.car_cmd_subs[req.name]
        # delete the odom, pose publishers (check if they exist first)
        if req.name in self.car_odom_pubs:
            self.car_odom_pubs[req.name].unregister()
            del self.car_odom_pubs[req.name]
        if req.name in self.car_pose_pubs:
            self.car_pose_pubs[req.name].unregister()
            del self.car_pose_pubs[req.name]

        # Delete cars body from pybullet by called sim.delete_car
        res = self.sim.delete_car(self.car_ids[req.name])
        del self.car_ids[req.name]

        self.reset_lock.release()
        return DeleteCarResponse(res)

    def reset_cb(self):
        """                                                    `
        Resets the simulator for the next run
        @return: nothing broke response
        """

        self.reset_lock.acquire()
        # generate new simulator bounds
        spawn_bounds = self.get_spawn_bounds()

        # self.generate_car_properties()
        # Reset the sim.py for each car
        self.sim.reset(spawn_bounds, self.car_properties)

        self.last_time = None
        self.reset_lock.release()
        return EmptyResponse()

    def loop_once(self):
        """
        Step the simulation once step
        updates the match status (if someone scores)
        - moves the ball and car positions to their positions
        - publishes the new car and ball position
        """
        self.reset_lock.acquire()
        now = rospy.Time.now()
        if self.last_time is not None and self.last_time != now:
            # Iterate sim one step
            delta_t = (now - self.last_time).to_sec()
            self.sim.step(delta_t)

            # Publish game status
            status = MatchStatus()
            if self.sim.scored:
                if self.sim.winner == "A":
                    status.status = MatchStatus.VICTORY_TEAM_A
                elif self.sim.winner == "B":
                    status.status = MatchStatus.VICTORY_TEAM_B
            else:
                status.status = MatchStatus.ONGOING
            self.status_pub.publish(status)

            # Publish pose and odometry data
            if self.mode == SimulatorMode.REALISTIC:
                ball_msg = PoseWithCovarianceStamped()
                ball_msg.header.stamp = now
                ball_msg.header.frame_id = self.frame_id
                ball_pos, ball_quat = self.sim.get_ball_pose(add_noise=True)
                ball_msg.pose.pose.position.x = ball_pos[0]
                ball_msg.pose.pose.position.y = ball_pos[1]
                ball_msg.pose.pose.position.z = ball_pos[2]
                ball_msg.pose.pose.orientation.x = ball_quat[0]
                ball_msg.pose.pose.orientation.y = ball_quat[1]
                ball_msg.pose.pose.orientation.z = ball_quat[2]
                ball_msg.pose.pose.orientation.w = ball_quat[3]
                self.ball_pose_pub.publish(ball_msg)

                for car_name in self.car_ids:
                    car_msg = PoseWithCovarianceStamped()
                    car_msg.header.stamp = now
                    car_msg.header.frame_id = self.frame_id
                    car_pos, car_quat = self.sim.get_car_pose(
                        self.car_ids[car_name], add_noise=True)
                    car_msg.pose.pose.position.x = car_pos[0]
                    car_msg.pose.pose.position.y = car_pos[1]
                    car_msg.pose.pose.position.z = car_pos[2]
                    car_msg.pose.pose.orientation.x = car_quat[0]
                    car_msg.pose.pose.orientation.y = car_quat[1]
                    car_msg.pose.pose.orientation.z = car_quat[2]
                    car_msg.pose.pose.orientation.w = car_quat[3]
                    self.car_pose_pubs[car_name].publish(car_msg)
            ball_msg = Odometry()
            ball_msg.header.stamp = now
            ball_msg.header.frame_id = self.frame_id
            ball_pos, ball_quat = self.sim.get_ball_pose()
            ball_msg.pose.pose.position.x = ball_pos[0]
            ball_msg.pose.pose.position.y = ball_pos[1]
            ball_msg.pose.pose.position.z = ball_pos[2]
            ball_msg.pose.pose.orientation.x = ball_quat[0]
            ball_msg.pose.pose.orientation.y = ball_quat[1]
            ball_msg.pose.pose.orientation.z = ball_quat[2]
            ball_msg.pose.pose.orientation.w = ball_quat[3]
            ball_linear, ball_angular = self.sim.get_ball_velocity()
            ball_msg.twist.twist.linear.x = ball_linear[0]
            ball_msg.twist.twist.linear.y = ball_linear[1]
            ball_msg.twist.twist.linear.z = ball_linear[2]
            ball_msg.twist.twist.angular.x = ball_angular[0]
            ball_msg.twist.twist.angular.y = ball_angular[1]
            ball_msg.twist.twist.angular.z = ball_angular[2]
            self.ball_odom_pub.publish(ball_msg)

            for car_name in self.car_ids:
                car_msg = Odometry()
                car_msg.header.stamp = now
                car_msg.header.frame_id = self.frame_id
                car_pos, car_quat = self.sim.get_car_pose(
                    self.car_ids[car_name])
                car_msg.pose.pose.position.x = car_pos[0]
                car_msg.pose.pose.position.y = car_pos[1]
                car_msg.pose.pose.position.z = car_pos[2]
                car_msg.pose.pose.orientation.x = car_quat[0]
                car_msg.pose.pose.orientation.y = car_quat[1]
                car_msg.pose.pose.orientation.z = car_quat[2]
                car_msg.pose.pose.orientation.w = car_quat[3]
                car_linear, car_angular = self.sim.get_car_velocity(
                    self.car_ids[car_name])
                car_msg.twist.twist.linear.x = car_linear[0]
                car_msg.twist.twist.linear.y = car_linear[1]
                car_msg.twist.twist.linear.z = car_linear[2]
                car_msg.twist.twist.angular.x = car_angular[0]
                car_msg.twist.twist.angular.y = car_angular[1]
                car_msg.twist.twist.angular.z = car_angular[2]
                self.car_odom_pubs[car_name].publish(car_msg)

        self.last_time = now
        self.reset_lock.release()

    def get_sim_param(self, path, returnValue=False, secondParam=None):
        """
        gets a simulator parameter
        @param secondParam: if you want to get another value from rospy
        @param path: the path to the variable
        @param returnValue:
        true: if variable does not exist, None is return
        false: if variable does not exist, an error is thrown
        @return: None
        """
        rospy_param = rospy.get_param(path)
        if not rospy_param:
            if returnValue:
                rospy.logfatal(f'invalid file path: ${path}')
            return None
        else:
            type_rospy = type(rospy_param)
            if type_rospy == dict:
                if secondParam is None:
                    min_param = rospy.get_param(f'${path}/min')
                    max_param = rospy.get_param(f'${path}/max')
                else:
                    min_param = rospy.get_param(f'${path}/min', secondParam)
                    max_param = rospy.get_param(f'${path}/max', secondParam)

                if not max_param:
                    if returnValue:
                        rospy.logfatal(f'invalid file path: ${path}/max')
                    return None
                if not min_param:
                    if returnValue:
                        rospy.logfatal(f'invalid file path: ${path}/min')
                    return None
                # accounting for moments in yaml file
                if min_param > max_param:
                    return random.uniform(max_param, min_param)
                else:
                    return random.uniform(min_param, max_param)

            elif type_rospy == float or type_rospy == int:
                if secondParam is None:
                    return rospy.get_param(path, secondParam)
                else:
                    return rospy.get_param(path)
        if returnValue:
            rospy.logfatal(f'invalid file path: ${path}')
        return None

    def get_sim_dict(self, path, throwException=False):
        """
        create a dictionary from the path variable
        @param path: the path to the dictianaly in the rospy yaml file
        @param throwException:
        true: if variable does not exist, None is return
        false: if variable does not exist, an error is thrown
        @return: None
        """
        rospy_param = rospy.get_param(path)
        if not rospy_param:
            if throwException:
                rospy.logfatal(f'invalid file path: ${path}')
            return None
        else:
            type_rospy = type(rospy_param)
            if type_rospy == dict:
                # check here if there are min and max values specified
                # if so, return the random values
                min_param = rospy.get_param(f'${path}/min')
                max_param = rospy.get_param(f'${path}/max')
                if not max_param and min_param:
                    if throwException:
                        rospy.logfatal(f'invalid file path: ${path}/max')
                    return None
                elif not min_param and max_param:
                    if throwException:
                        rospy.logfatal(f'invalid file path: ${path}/min')
                    return None
                elif max_param and min_param:
                    if min_param > max_param:
                        return random.uniform(max_param, min_param)
                    else:
                        return random.uniform(min_param, max_param)

                # bc not have max and min, this means that we have more dicts and vals to loop over
                for key in rospy_param:
                    # recurse down the path, using the key as the continuation
                    rospy_param[key] = self.get_sim_param(path + f'$/{key}', throwException)
                return rospy_param

            elif type_rospy == float or type_rospy == int or type_rospy == list:
                return rospy.get_param(path)
        if throwException:
            rospy.logfatal(f'invalid file path: ${path}')
        return None

    def get_spawn_bounds(self):
        """
        randomly generates the spawn bounds if we specify to generate random ones
        @return: the spawn bound array
        """
        # Setting up field
        fw = self.get_sim_param("/field/width")
        fl = self.get_sim_param("/field/length")
        spawn_height = rospy.get_sim_param('~spawn_height', secondParam=0.06)
        wt = rospy.get_sim_param('/field/wall_thickness')

        spawn_bounds = [[-(fl / 2) + (2 * wt), (fl / 2) - (2 * wt)],
                        [-(fw / 2) + (2 * wt), (fw / 2) - (2 * wt)],
                        [spawn_height, spawn_height]]
        return spawn_bounds

    def generate_car_properties(self):
        """
        Set the car parameters based on those provided in the rospy directory
        the properties of the car itself: length, max_speed, throttle, steering, simulate effort...
        Publisher:
            match_status
        Service:
            Sim_reset
            Sim_create_car
            sim_delete_Car
        @return: the generic car properties that are created for thsi specific run in a dictionary
        """

        car_properties = {'length': rospy.get_sim_param('/cars/length'),
                          'max_speed': self.get_sim_param("/cars/throttle/max_speed"),
                          'steering_throw': self.get_sim_param("/cars/throttle/max_steering_throw"),
                          'throttle_tau': rospy.get_sim_param("/cars/throttle/tau"),
                          'steering_rate': rospy.get_sim_param("/cars/steering/rate"),
                          'simulate_effort': (self.mode == SimulatorMode.REALISTIC)}
        self.car_properties = car_properties
        return car_properties

    def delete_all_cars(self):
        """
        loops over all of the cars and deletes each from the list
        unsubscribes from all publishers and subscribers in the process
        @return: whether deletion was successful
        """
        car_configs = self.get_sim_param('~cars', secondParam=[])
        self.reset_lock.acquire()
        for car_config in car_configs:
            # shutdown if the car does not exit
            if 'name' not in car_config:
                rospy.signal_shutdown('no "name" set for car config in sim')
            car_name = car_config['name']
            if 'randomize_pose' in car_config:
                init_pose = None
            # delete the car from the sim side
            self.sim.delete_car(self.car_ids[car_name])

            # Delete all of the cars subscribers
            if car_name in self.car_effort_subs:
                self.car_effort_subs[car_name].unregister()
                del self.car_effort_subs[car_name]
            if car_name in self.car_cmd_subs:
                self.car_cmd_subs[car_name].unregister()
                del self.car_cmd_subs[car_name]
            # delete all of the cars publishers
            if car_name in self.car_odom_pubs:
                self.car_odom_pubs[car_name].unregister()
                del self.car_odom_pubs[car_name]
            if car_name in self.car_pose_pubs:
                self.car_pose_pubs[car_name].unregister()
                del self.car_pose_pubs[car_name]
        # reset all lists to be safe
        self.car_ids = {}
        self.car_pose_pubs = {}
        self.car_odom_pubs = {}
        self.car_effort_subs = {}
        self.car_cmd_subs = {}
        self.reset_lock.release()

        return DeleteCarResponse(True)

    def generate_all_cars(self):
        """generate all the cars for the simulator run"""
        car_configs = self.get_sim_param('~cars',secondParam= [])

        for car_config in car_configs:
            init_pose = self.get_sim_param('~cars/init_pose')

            if 'name' not in car_config:
                rospy.signal_shutdown('no "name" set for car config in sim')
            car_name = car_config['name']
            if 'randomize_pose' in car_config:
                init_pose = None

            self.car_ids[car_name] = self.sim.create_car(
                'car', init_pose=init_pose, noise=self.car_noise, car_props=self.car_properties)

            car_id = self.car_ids[car_name]
            # Subscribers for the car
            self.car_effort_subs[car_name] = rospy.Subscriber(
                f'/cars/{car_name}/effort', ControlEffort,
                self.effort_cb, callback_args=car_id)
            self.car_cmd_subs[car_name] = rospy.Subscriber(
                f'/cars/{car_name}/command', ControlCommand,
                self.cmd_cb, callback_args=car_id)
            # publishers for the car
            if self.mode == SimulatorMode.REALISTIC:
                self.car_pose_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/pose_sync_early',
                    PoseWithCovarianceStamped, queue_size=1)
                self.car_odom_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/odom_truth', Odometry, queue_size=1)
            elif self.mode == SimulatorMode.IDEAL:
                self.car_odom_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/odom', Odometry, queue_size=1)
        return CreateCarResponse(True)


"""the main function: call the simulator to init the loop and create objects"""
if __name__ == "__main__":
    Simulator()
