#!/usr/bin/env python3
"""Node to run the simulator with ROS bindings.
License:
  BSD 3-Clause License
  Copyright (c) 2020, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
"""

# 3rd party modules
import random
from geometry_msgs.msg import PoseWithCovarianceStamped
from nav_msgs.msg import Odometry
import os
import rospy
from std_srvs.srv import Empty, EmptyResponse
from threading import Lock
from enum import Enum

# Local library
import simulator
from rktl_sim.srv import CreateCar, CreateCarResponse, DeleteCar, DeleteCarResponse
from rktl_msgs.msg import MatchStatus, ControlCommand, ControlEffort


class SimulatorMode(Enum):
    # NOTE: two types of models
    # ideal: no sensor noise, realistic: simulate sensor noise
    IDEAL = 1
    REALISTIC = 2


class Simulator(object):
    """ROS wrapper for the simulator.
    Get the mode in which run: ideal vs reaslistics
    Get the parameters at which run sim: (rate, frame, timeout)
    Set the spawn bounds
    Create the ball (position and speed)
    Loops over all cars for which it has a config, then out of each one: creates a tuple of:
    - Car id
    - Car pose pubs
    - Car odom pubs
    - Car effort subs
    - Car cmd subs

    simulator setup:
        create simp object from sim.py: param: props, urdf_paths, spawn_bounds, render_enabled
        setup sensor noise:
            get the ~sensor_noise param
        if sensor noise not defined and in REALISTIC mode
        - add noise to the ball
        - add noise to the car
        create the ball object: init the position and the speed
        sim.create_ball, param: 'ball', init_pose,init_speed, ball_noise

        if REALISTIC:
        ball_pose_pub publisher: /ball/pose_sync_early
        ball_odom_pub publisher: /ball/odom_truth
        if IDEAL:
        ball_odom_pub: /ball/odom

    Initialize the ball object finding the parameter from ~ball/init_pose or init_speed
    (depend on whether using realistic or ideal model)
    Init the ball odometry depending on whether we are using a realistic model or not


    After initializing everything above,
    Loop while rospy is not shutdown

    """

    class InvalidRospyParam(Exception):
        """exception when using invalid arguement"""
        print(Exception)
        rospy.logfatal()

    def __init__(self):
        # create variables for the functions that might initialize them

        rospy.init_node('simulator')
        # init the simulator and the sim time

        # - the mode of which we will run simulator: ideal or realistic
        # - the frame id of the specific run
        # - the timeout associated with a pause
        # - the rate at which we will run the simulator
        # - whether we want to render during the run of the simulator
        # the different nodes determine whether there is noise or not
        mode = rospy.get_param('~mode')
        if mode == 'ideal':
            self.mode = SimulatorMode.IDEAL
        elif mode == 'realistic':
            self.mode = SimulatorMode.REALISTIC
        else:
            rospy.signal_shutdown('unknown sim mode set "{}"'.format(mode))

        # set the engine environment
        render_enabled = rospy.get_param('~render', False)
        rate = rospy.Rate(rospy.get_param('~rate', 30))
        self.frame_id = rospy.get_param('~frame_id', 'map')
        self.timeout = rospy.get_param('~timeout', 10)

        # Setup bounds for spawning car and ball
        spawn_bounds = self.get_spawn_bounds()

        # urdf file: unversial way to describe kinematics and dynamics of robots
        # the simulator use urdf to generate models for car, boalll , field bonds
        # when aluch the node, pass in the param of urdf param - generated dynamically
        # have all of the models need to load sym
        urdf_paths = rospy.get_param('~urdf')
        for path in urdf_paths.values():
            self.check_urdf(path)
        # bc created get_rospy_param fun: want to change things
        # describe a lot of sim's internal paramnters

        # Setup simulator properties
        props = {
            'engine': rospy.get_param('~engine', None),
            'dynamics': rospy.get_param('~dynamics', None),
        }

        # Creating physics simulator
        self.sim = simulator.Sim(props, urdf_paths, spawn_bounds, render_enabled)

        # Setting sensor noise
        self.car_noise, self.ball_noise = self.set_sensor_noise()

        # Creating the ball
        # check if we want to randomize the ball properties (ball pos and ball vel)
        # if we want to randomize, then we will do so in the sim.py

        self.ball_pose_pub, self.ball_odom_pub = None, None
        ball_init_pose = rospy.get_sim_param('~ball/init_pose', None)
        ball_init_speed = rospy.get_sim_param('~ball/init_speed', None)

        self.sim.create_ball('ball', init_pose=ball_init_pose,
                             init_speed=ball_init_speed, noise=self.ball_noise)
        if self.mode == SimulatorMode.REALISTIC:
            self.ball_pose_pub = rospy.Publisher('/ball/pose_sync_early',
                                                 PoseWithCovarianceStamped, queue_size=1)
            self.ball_odom_pub = rospy.Publisher('/ball/odom_truth',
                                                 Odometry, queue_size=1)
        elif self.mode == SimulatorMode.IDEAL:
            self.ball_odom_pub = rospy.Publisher('/ball/odom',
                                                 Odometry, queue_size=1)

        # generate car properties
        self.car_properties = self.generate_car_properties()

        # important variables for the car publishers, subscribers, and so on
        self.car_ids = {}
        self.car_pose_pubs = {}
        self.car_odom_pubs = {}
        self.car_effort_subs = {}
        self.car_cmd_subs = {}
        self.generate_all_cars()

        # create a list of car properties for each potential car that there could be

        # Node data
        self.cmd_lock = Lock()
        self.reset_lock = Lock()
        self.last_time = None

        # Publishers
        self.status_pub = rospy.Publisher(
            'match_status', MatchStatus, queue_size=1)

        # Services
        rospy.Service('sim_reset', Empty, self.reset_cb)
        rospy.Service('sim_create_car', CreateCar, self.create_car_cb)
        rospy.Service('sim_delete_car', DeleteCar, self.delete_car_cb)

        while not rospy.is_shutdown():
            self.loop_once()
            try:
                rate.sleep()
            except rospy.ROSInterruptException:
                pass

    def check_urdf(self, param):
        """
        overview: Checks whether you ahvea valid pybullet url for information
        if not, wait for the file to build in .5 seconds
        Validates that a URDF exists, then returns path
        """
        if param is None:
            rospy.signal_shutdown('no urdf path set for "{}"'.format(param))

        i = 0
        while not os.path.isfile(param) and i < 5:
            rospy.sleep(0.1)  # Wait for xacro build
            i += 1

        if not os.path.isfile(param):
            rospy.signal_shutdown(
                'no urdf file exists at path {}'.format(param))

    # TODO: how do effort_cb and cmd_cb interact?

    def effort_cb(self, effort_msg, car_id):
        """
        Sets a car's effort (overwrites commands)
        Overrides the cmd_cb: calls the car command with the throttle and steering
        TODO: during which state is it called with
        """
        self.cmd_lock.acquire()
        self.sim.set_car_command(car_id,
                                 (effort_msg.throttle, effort_msg.steering))
        self.cmd_lock.release()

    def cmd_cb(self, cmd_msg, car_id):
        """
        Overrides the effirt_cd: calls the car
        Command with the velocity and the curvature
        Sets a car's command (overwrites efforts)
        """
        self.cmd_lock.acquire()
        self.sim.set_car_command(car_id,
                                 (cmd_msg.velocity, cmd_msg.curvature))
        self.cmd_lock.release()

    def create_car_cb(self, req):
        """
        Add new car to the simulator
        Checks if resetting to random position:
        - if not, set it to default
        - if so, will be reset later in the sim.create_car function

        Get the car id,
        Subscribe:
        - effort cb: args: car_id
        - command cb: args: car_id
        If realistic mode:
        - Publish to the pose sync early (with car id)
        - Publish to the odometry truth (with car id)
        If ideal mode:
        - Publish to the odometry (with car id)
        """
        self.reset_lock.acquire()
        if req.name in self.car_ids:
            return CreateCarResponse(False)

        init_pose = None
        if req.reset_to_random_pose is False:
            init_pose = {
                "pos": [req.init_pos.x,
                        req.init_pos.y,
                        req.init_pos.z],
                "orient": [0.0, 0.0, req.init_yaw],
            }

        self.car_ids[req.name] = self.sim.create_car(
            'car', init_pose, noise=self.car_noise, props=self.car_properties)

        car_id = self.car_ids[req.name]
        self.car_effort_subs[req.name] = rospy.Subscriber(
            f'/cars/{req.name}/effort', ControlEffort,
            self.effort_cb, callback_args=car_id)
        self.car_cmd_subs[req.name] = rospy.Subscriber(
            f'/cars/{req.name}/command', ControlCommand,
            self.cmd_cb, callback_args=car_id)

        if self.mode == SimulatorMode.REALISTIC:
            self.car_pose_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/pose_sync_early',
                PoseWithCovarianceStamped, queue_size=1)
            self.car_odom_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/odom_truth', Odometry, queue_size=1)
        elif self.mode == SimulatorMode.IDEAL:
            self.car_odom_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/odom', Odometry, queue_size=1)

        self.reset_lock.release()
        return CreateCarResponse(True)

    def delete_car_cb(self, req):
        """
        Remove car from the simulator
        Delete the effort,cmd subs (check if they exist first)
        delete the odom, pose publishers (check if they exist first)
        Delete cars body from pybullet by called sim.delete_car
        """
        self.reset_lock.acquire()
        if req.name not in self.car_ids:
            return DeleteCarResponse(False)

        # Delete all related pubs and subs
        if req.name in self.car_effort_subs:
            self.car_effort_subs[req.name].unregister()
            del self.car_effort_subs[req.name]
        if req.name in self.car_cmd_subs:
            self.car_cmd_subs[req.name].unregister()
            del self.car_cmd_subs[req.name]

        if req.name in self.car_odom_pubs:
            self.car_odom_pubs[req.name].unregister()
            del self.car_odom_pubs[req.name]
        if req.name in self.car_pose_pubs:
            self.car_pose_pubs[req.name].unregister()
            del self.car_pose_pubs[req.name]

        # Delete the car's body from pybullet
        res = self.sim.delete_car(self.car_ids[req.name])
        del self.car_ids[req.name]

        self.reset_lock.release()
        return DeleteCarResponse(res)

    def reset_cb(self):
        """
        Resets the simulator
        Reset the sim.py for each car
        Rest the time
        Reset the car_cmd
        reset the simulator parameters and the sim class itself
        @return: nothing broke response
        """
        # TODO: want to give lest work with generating car properties

        # OTHER NOTES:
        # parametrsr loaded form ros param server: init value read from config: bc collecting data from paths,
        # can update them real time
        # if wanted just range over tiem and increasedd the range as we train -we can do : can publish new values to the parameters
        # each time call reset: update with new knowledge and change how do domain randomizaiton
        # think of ways to ad more paramters and make more adaptable

        # self.configure_dynamics(self.plnae_id)- avoid generating a new data file: outsource all of that to doing computation in ros
        # instead of rereading the paramters and storing them: can have function that reads param again if change max and min
        # do the computation in the simulator node
        # then pass that computation to the configure dynamics file

        # other: adding functionality to autonomy pachage
        # train_rocket_league.py;
        # waht about rocket_league_interface: they are pulling in paramters there (under rktl_autonomy)
        # want to add functionality to set ranges between runs: after each run: want to increase the range of param by 0.1
        # as we conifugre that: there is another function :they use rospy.getparam: there is a setparam function: use between runs
        # for autonomy pacakge: want to do: might not be immediately aware what param available to update bc use sim.configure file
        # can add apram to simulator.yaml: can include a publish param that we are currently using: set out list
        # and process them: "sim configurable params' has list of apram names used by the simulator
        # autonomy can check that parameter and find all of the things it is allwoed to change
        # that was it iss independent of the simulator that is runnign :in the future can add more params and understand they exist
        # or if they want to take away params
        # bc this is one time thing: makes it to be a list in sim.yaml file: whatever devs of sim nodes know to chagne

        # as part of autonomy side: oportunity to explore literature online
        # many techniques for how do; want to account for soeme of them and think of what features add to support it

        # good skill pull up brand new project and understand it

        self.reset_lock.acquire()

        # TODO: need to pass key variables to the rest function located in the sim class
        spawn_bounds = self.get_spawn_bounds()

        self.generate_car_properties()
        self.sim.reset(spawn_bounds, self.car_properties)

        self.last_time = None
        self.reset_lock.release()
        return EmptyResponse()

    def loop_once(self):
        """
        Pause the time
        Step the simulation once step
        Update the match status: if either team scored, show the winner, if not, continue the match

        If the simulation mode is realistic:
        - Write the ball positing and orientation variables (pub)
        - Write each cars position and orientation variables (pub)
        For all modes (ideal and realistic):
        Move the ball forward: get its position, and publish it (via Odometry() func)
        For each car, move it forward, get its position and publish it (via Odometry() func)
        Resume the time
        """
        self.reset_lock.acquire()
        now = rospy.Time.now()
        if self.last_time is not None and self.last_time != now:
            # Iterate sim one step
            delta_t = (now - self.last_time).to_sec()
            self.sim.step(delta_t)

            # Publish game status
            status = MatchStatus()
            if self.sim.scored:
                if self.sim.winner == "A":
                    status.status = MatchStatus.VICTORY_TEAM_A
                elif self.sim.winner == "B":
                    status.status = MatchStatus.VICTORY_TEAM_B
            else:
                status.status = MatchStatus.ONGOING
            self.status_pub.publish(status)

            # Publish pose and odometry data
            if self.mode == SimulatorMode.REALISTIC:
                ball_msg = PoseWithCovarianceStamped()
                ball_msg.header.stamp = now
                ball_msg.header.frame_id = self.frame_id
                ball_pos, ball_quat = self.sim.get_ball_pose(add_noise=True)
                ball_msg.pose.pose.position.x = ball_pos[0]
                ball_msg.pose.pose.position.y = ball_pos[1]
                ball_msg.pose.pose.position.z = ball_pos[2]
                ball_msg.pose.pose.orientation.x = ball_quat[0]
                ball_msg.pose.pose.orientation.y = ball_quat[1]
                ball_msg.pose.pose.orientation.z = ball_quat[2]
                ball_msg.pose.pose.orientation.w = ball_quat[3]
                self.ball_pose_pub.publish(ball_msg)

                for car_name in self.car_ids:
                    car_msg = PoseWithCovarianceStamped()
                    car_msg.header.stamp = now
                    car_msg.header.frame_id = self.frame_id
                    car_pos, car_quat = self.sim.get_car_pose(
                        self.car_ids[car_name], add_noise=True)
                    car_msg.pose.pose.position.x = car_pos[0]
                    car_msg.pose.pose.position.y = car_pos[1]
                    car_msg.pose.pose.position.z = car_pos[2]
                    car_msg.pose.pose.orientation.x = car_quat[0]
                    car_msg.pose.pose.orientation.y = car_quat[1]
                    car_msg.pose.pose.orientation.z = car_quat[2]
                    car_msg.pose.pose.orientation.w = car_quat[3]
                    self.car_pose_pubs[car_name].publish(car_msg)
            ball_msg = Odometry()
            ball_msg.header.stamp = now
            ball_msg.header.frame_id = self.frame_id
            ball_pos, ball_quat = self.sim.get_ball_pose()
            ball_msg.pose.pose.position.x = ball_pos[0]
            ball_msg.pose.pose.position.y = ball_pos[1]
            ball_msg.pose.pose.position.z = ball_pos[2]
            ball_msg.pose.pose.orientation.x = ball_quat[0]
            ball_msg.pose.pose.orientation.y = ball_quat[1]
            ball_msg.pose.pose.orientation.z = ball_quat[2]
            ball_msg.pose.pose.orientation.w = ball_quat[3]
            ball_linear, ball_angular = self.sim.get_ball_velocity()
            ball_msg.twist.twist.linear.x = ball_linear[0]
            ball_msg.twist.twist.linear.y = ball_linear[1]
            ball_msg.twist.twist.linear.z = ball_linear[2]
            ball_msg.twist.twist.angular.x = ball_angular[0]
            ball_msg.twist.twist.angular.y = ball_angular[1]
            ball_msg.twist.twist.angular.z = ball_angular[2]
            self.ball_odom_pub.publish(ball_msg)

            for car_name in self.car_ids:
                car_msg = Odometry()
                car_msg.header.stamp = now
                car_msg.header.frame_id = self.frame_id
                car_pos, car_quat = self.sim.get_car_pose(
                    self.car_ids[car_name])
                car_msg.pose.pose.position.x = car_pos[0]
                car_msg.pose.pose.position.y = car_pos[1]
                car_msg.pose.pose.position.z = car_pos[2]
                car_msg.pose.pose.orientation.x = car_quat[0]
                car_msg.pose.pose.orientation.y = car_quat[1]
                car_msg.pose.pose.orientation.z = car_quat[2]
                car_msg.pose.pose.orientation.w = car_quat[3]
                car_linear, car_angular = self.sim.get_car_velocity(
                    self.car_ids[car_name])
                car_msg.twist.twist.linear.x = car_linear[0]
                car_msg.twist.twist.linear.y = car_linear[1]
                car_msg.twist.twist.linear.z = car_linear[2]
                car_msg.twist.twist.angular.x = car_angular[0]
                car_msg.twist.twist.angular.y = car_angular[1]
                car_msg.twist.twist.angular.z = car_angular[2]
                self.car_odom_pubs[car_name].publish(car_msg)

        self.last_time = now
        self.reset_lock.release()

    def get_sim_dict(self, path):

        if not rospy.get_param(path):
            raise self.InvalidRospyParam(path)
        else:
            type_rospy = type(rospy.get_param(path))

            if type_rospy == dict:
                min_param = rospy.get_param(f'${path}/min')
                max_param = rospy.get_param(f'${path}/max')

                if not max_param:
                    raise self.InvalidRospyParam(f'${path}/max')
                if not min_param:
                    raise self.InvalidRospyParam(f'${path}/min')
                # accounting for moments in yaml file
                if min_param > max_param:
                    return random.uniform(max_param, min_param)
                else:
                    return random.uniform(min_param, max_param)

            elif type_rospy == float or type_rospy == int:
                return rospy.get_param(path)

    def get_sim_param(self, path):
        """
        create a dictionary from the path variable

        process:
        check if the initial path exist in rospy. if not, throw error
        check if its a dict, if so, check if have min and max, if so, generate random param
        if not, return a value if its a float, integer or list

        if not have min and max, for each key of the dictionary, recurse down the tree by calling the same function

        @param path: the path to the parameter in the yaml file
        @return: either the variable or the complete dictionary, depending on the path taken during recurssion
        """
        rospy_param = rospy.get_param(path)
        if not rospy_param:
            raise self.InvalidRospyParam(path)
        else:
            type_rospy = type(rospy_param)
            if type_rospy == dict:
                # check here if there are min and max values specified
                # if so, return the random values
                min_param = rospy.get_param(f'${path}/min')
                max_param = rospy.get_param(f'${path}/max')
                if not max_param and min_param:
                    raise self.InvalidRospyParam(f'${path}/max')
                elif not min_param and max_param:
                    raise self.InvalidRospyParam(f'${path}/min')
                elif max_param and min_param:
                    if min_param > max_param:
                        return random.uniform(max_param, min_param)
                    else:
                        return random.uniform(min_param, max_param)

                # bc not have max and min, this means that we have more dicts and vals to loop over
                for key in rospy_param:
                    # recurse down the path, using the key as the continuation
                    rospy_param[key] = self.get_sim_param(path + f'$/{key}')
                return rospy_param

            elif type_rospy == float or type_rospy == int or type_rospy == list:
                return rospy.get_param(path)

        raise self.InvalidRospyParam(path)

    def get_spawn_bounds(self):
        """
        randomly generates the spawn bounds if we specify to generate random ones
        @return: the spawn bound array
        """
        # Setting up field
        fw = self.get_sim_param("/field/width")
        fl = self.get_sim_param("/field/length")
        spawn_height = rospy.get_sim_param('~spawn_height', 0.06)
        wt = rospy.get_sim_param('/field/wall_thickness')

        spawn_bounds = [[-(fl / 2) + (2 * wt), (fl / 2) - (2 * wt)],
                        [-(fw / 2) + (2 * wt), (fw / 2) - (2 * wt)],
                        [spawn_height, spawn_height]]
        return spawn_bounds

    def generate_car_properties(self):
        """
        Set the car parameters based on those provided in the rospy directory (the properties of the car itself: length, max_speed, throttle, steering, simulate effort, etc)
        - generates random max speed and steering throw by calling other functions
        - used to generate these properties for each car
        Create a list for each car depending on its properties:
            Car id
            Car pose publisher
            Car odom publisher
            Car effort subscribers
            Car command subscribers
        Publisher:
            match_status
        Service:
            Sim_reset
            Sim_create_car
            sim_delete_Car
        @return the generic car properties that are created for thsi specific run in a dictionary
        """
        # general paramters that are the same for every single car
        # if too constrained in car length between what we detect and what it is - might learn differently
        # use the get_sim_param in each function case: makes the most sense
        car_properties = {'length': rospy.get_sim_param('/cars/length'),
                          'max_speed': self.get_sim_param("/cars/throttle/max_speed"),
                          'steering_throw': self.get_sim_param("/cars/throttle/max_steering_throw"),
                          'throttle_tau': rospy.get_sim_param("/cars/throttle/tau"),
                          'steering_rate': rospy.get_sim_param("/cars/steering/rate"),
                          'simulate_effort': (self.mode == SimulatorMode.REALISTIC)}
        self.car_properties = car_properties
        return car_properties

    def delete_all_cars(self):
        car_configs = rospy.get_param('~cars', [])
        self.reset_lock.acquire()
        for car_config in car_configs:

            if 'name' not in car_config:
                rospy.signal_shutdown('no "name" set for car config in sim')
            car_name = car_config['name']


            self.sim.delete_car(self.car_ids[car_name])

            # Delete all of hte cars subscribers
            if car_name in self.car_effort_subs:
                self.car_effort_subs[car_name].unregister()
                del self.car_effort_subs[car_name]
            if car_name in self.car_cmd_subs:
                self.car_cmd_subs[car_name].unregister()
                del self.car_cmd_subs[car_name]
            # delete all of the cars publishers
            if car_name in self.car_odom_pubs:
                self.car_odom_pubs[car_name].unregister()
                del self.car_odom_pubs[car_name]
            if car_name in self.car_pose_pubs:
                self.car_pose_pubs[car_name].unregister()
                del self.car_pose_pubs[car_name]
        # reseting vars to be safe
        self.car_ids = {}
        self.car_pose_pubs = {}
        self.car_odom_pubs = {}
        self.car_effort_subs = {}
        self.car_cmd_subs = {}
        self.reset_lock.release()

        return DeleteCarResponse(True)

    def generate_all_cars(self):
        car_configs = rospy.get_param('~cars', [])

        for car_config in car_configs:
            init_pose = None
            if 'init_pose' in car_config:
                init_pose = car_config['init_pose']

            if 'name' not in car_config:
                rospy.signal_shutdown('no "name" set for car config in sim')
            car_name = car_config['name']


            self.car_ids[car_name] = self.sim.create_car(
                'car', init_pose=init_pose, noise=self.car_noise, car_props=self.car_properties)

            car_id = self.car_ids[car_name]
            self.car_effort_subs[car_name] = rospy.Subscriber(
                f'/cars/{car_name}/effort', ControlEffort,
                self.effort_cb, callback_args=car_id)
            self.car_cmd_subs[car_name] = rospy.Subscriber(
                f'/cars/{car_name}/command', ControlCommand,
                self.cmd_cb, callback_args=car_id)

            if self.mode == SimulatorMode.REALISTIC:
                self.car_pose_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/pose_sync_early',
                    PoseWithCovarianceStamped, queue_size=1)
                self.car_odom_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/odom_truth', Odometry, queue_size=1)
            elif self.mode == SimulatorMode.IDEAL:
                self.car_odom_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/odom', Odometry, queue_size=1)

        return CreateCarResponse(True)

    def set_sensor_noise(self):
        """
        adds the sensor noise for the car and for the ball
        @return: the sensor noises for the ball and for the car
        """
        sensor_noise = rospy.get_sim_param('~sensor_noise', None)
        ball_noise = None
        car_noise = None
        if sensor_noise is not None and self.mode == SimulatorMode.REALISTIC:
            ball_noise = sensor_noise.get('ball', None)
            car_noise = sensor_noise.get('car', None)
        self.car_noise = car_noise
        self.ball_noise = ball_noise
        return car_noise, ball_noise


"""the main function: call the simulator to init the loop and create objects"""
if __name__ == "__main__":
    Simulator()
