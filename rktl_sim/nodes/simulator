#!/usr/bin/env python3
"""Node to run the simulator with ROS bindings.
License:
  BSD 3-Clause License
  Copyright (c) 2020, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
"""

# 3rd party modules
import random
from geometry_msgs.msg import PoseWithCovarianceStamped
from nav_msgs.msg import Odometry
import os
import rospy
from std_srvs.srv import Empty, EmptyResponse
from threading import Lock
from enum import Enum

# Local library
import simulator
from rktl_sim.srv import CreateCar, CreateCarResponse, DeleteCar, DeleteCarResponse
from rktl_msgs.msg import MatchStatus, ControlCommand, ControlEffort


# TODO: why not use a struct/ something simpler than a class here?
class SimulatorMode(Enum):
    # NOTE: two types of models
    # ideal: no sensor noise, realistic: simulate sensor noise
    IDEAL = 1
    REALISTIC = 2


class Simulator(object):
    """ROS wrapper for the simulator.
    Get the mode in which run: ideal vs reaslistics
    Get the parameters at which run sim: (rate, frame, timeout)
    Set the spawn bounds
    Create the ball (position and speed)
    Loops over all cars for which it has a config, then out of each one: creates a tuple of:
    - Car id
    - Car pose pubs
    - Car odom pubs
    - Car effort subs
    - Car cmd subs

    simulator setup:
        create simp object from sim.py: param: props, urdf_paths, spawn_bounds, render_enabled
        setup sensor noise:
            get the ~sensor_noise param
        if sensor noise not defined and in REALISTIC mode
        - add noise to the ball
        - add noise to the car
        create the ball object: init the position and the speed
        sim.create_ball, param: 'ball', init_pose,init_speed, ball_noise

        if REALISTIC:
        ball_pose_pub publisher: /ball/pose_sync_early
        ball_odom_pub publisher: /ball/odom_truth
        if IDEAL:
        ball_odom_pub: /ball/odom

    Initialize the ball object finding the parameter from ~ball/init_pose or init_speed (depend on whether using realistic or ideal model)
    Init the ball odometry depending on whether we are using a realistic model or not
    Set the car parameters based on those provided in the rospy directory (the properties of the car itself: length, max_speed, throttle, steering, simulate effort, etc)

    Create a list for each car depending on its properties:
        Car id
        Car pose publisher
        Car odom publisher
        Car effort subscribers
        Car command subscribers
    Publisher:
        match_status
    Service:
        Sim_reset
        Sim_create_car
        sim_delete_Car

    After initializing everything above,
    Loop while rospy is not shutdown

    """

    def __init__(self):
        rospy.init_node('simulator')
        # the different nodes determine whether their is noise or not
        mode = rospy.get_param('~mode')
        if mode == 'ideal':
            self.mode = SimulatorMode.IDEAL
        elif mode == 'realistic':
            self.mode = SimulatorMode.REALISTIC
        else:
            rospy.signal_shutdown('unknown sim mode set "{}"'.format(mode))

        render_enabled = rospy.get_param('~render', False)
        rate = rospy.Rate(rospy.get_param('~rate', 30))
        self.frame_id = rospy.get_param('~frame_id', 'map')
        self.timeout = rospy.get_param('~timeout', 10)

        # Setting up field
        # TODO: need to add these parameters, but where??
        randomize_field = rospy.get_param('/field/randomize_field')
        """
        the default paramters used inthe creation of the field
        width/length_1: either default, or one of the ranodmization bounds
        
        """
        fw1 = rospy.get_param('/field/width_1')
        fl1 = rospy.get_param('/field/length_1')
        wt = rospy.get_param('/field/wall_thickness')
        spawn_height = rospy.get_param('~spawn_height', 0.06)
        if randomize_field:
            fw2 = rospy.get_param('/field/width_2')
            fl2 = rospy.get_param('/field/length_2')
            fw, fl = self.get_rand_spawn_bounds(fw1, fw2, fl1, fl2)
        else:
            fw = fw1
            fl = fl1
        spawn_bounds = [[-(fl / 2) + (2 * wt), (fl / 2) - (2 * wt)],
                        [-(fw / 2) + (2 * wt), (fw / 2) - (2 * wt)],
                        [spawn_height, spawn_height]]

        # Setup bounds for spawning car and ball

        # TODO: waht is a urdf?
        urdf_paths = rospy.get_param('~urdf')
        for path in urdf_paths.values():
            self.check_urdf(path)

        # Setup simulator properties
        props = {
            'engine': rospy.get_param('~engine', None),
            'dynamics': rospy.get_param('~dynamics', None),
        }

        # Creating physics simulator
        self.sim = simulator.Sim(props, urdf_paths, spawn_bounds, render_enabled)

        # Setting sensor noise
        sensor_noise = rospy.get_param('~sensor_noise', None)
        ball_noise = None
        car_noise = None
        if sensor_noise is not None and self.mode == SimulatorMode.REALISTIC:
            ball_noise = sensor_noise.get('ball', None)
            car_noise = sensor_noise.get('car', None)
        self.car_noise = car_noise

        # Creating the ball
        # TODO: need to potentially chagne the init pose here
        ball_init_pose = rospy.get_param('~ball/init_pose', None)
        ball_init_speed = rospy.get_param('~ball/init_speed', None)
        # TODO: need to add these parameters that I am missing
        randomize_ball_pos = rospy.get_param('/field/randomize_ball_pose')
        randomize_ball_vel = rospy.get_param('/field/randomize_ball_vel')

        if randomize_ball_pos:
            ball_init_pose = None
        if randomize_ball_vel:
            ball_init_speed = None

        self.sim.create_ball('ball', init_pose=ball_init_pose,
                             init_speed=ball_init_speed, noise=ball_noise)
        if self.mode == SimulatorMode.REALISTIC:
            self.ball_pose_pub = rospy.Publisher('/ball/pose_sync_early',
                                                 PoseWithCovarianceStamped, queue_size=1)
            self.ball_odom_pub = rospy.Publisher('/ball/odom_truth',
                                                 Odometry, queue_size=1)
        elif self.mode == SimulatorMode.IDEAL:
            self.ball_odom_pub = rospy.Publisher('/ball/odom',
                                                 Odometry, queue_size=1)
        # TODO: possible bug bc generating locations and cars might overlap
        car_properties = {}
        car_properties['length'] = rospy.get_param('/cars/length')

        # TODO: need to update these paramters in the yaml
        car_properties['max_speed'] = self.generate_max_speed()
        car_properties['steering_throw'] = self.generate_steering_throw()

        car_properties['throttle_tau'] = rospy.get_param('/cars/throttle/tau')
        car_properties['steering_rate'] = rospy.get_param('/cars/steering/rate')
        car_properties['simulate_effort'] = (self.mode == SimulatorMode.REALISTIC)
        self.car_properties = car_properties

        # create a list of car properties for each potential car that there could be
        self.car_ids = {}
        self.car_pose_pubs = {}
        self.car_odom_pubs = {}
        self.car_effort_subs = {}
        self.car_cmd_subs = {}
        car_configs = rospy.get_param('~cars', [])
        for car_config in car_configs:
            init_pose = None
            if 'init_pose' in car_config:
                init_pose = car_config['init_pose']

            if 'name' not in car_config:
                rospy.signal_shutdown('no "name" set for car config in sim')
            car_name = car_config['name']
            # TODO: need to add randomization of position to the car configs
            if 'randomize_pose' in car_config:
                init_pose = None

            self.car_ids[car_name] = self.sim.create_car(
                'car', init_pose=init_pose, noise=car_noise, car_props=car_properties)

            car_id = self.car_ids[car_name]
            self.car_effort_subs[car_name] = rospy.Subscriber(
                f'/cars/{car_name}/effort', ControlEffort,
                self.effort_cb, callback_args=car_id)
            self.car_cmd_subs[car_name] = rospy.Subscriber(
                f'/cars/{car_name}/command', ControlCommand,
                self.cmd_cb, callback_args=car_id)

            if self.mode == SimulatorMode.REALISTIC:
                self.car_pose_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/pose_sync_early',
                    PoseWithCovarianceStamped, queue_size=1)
                self.car_odom_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/odom_truth', Odometry, queue_size=1)
            elif self.mode == SimulatorMode.IDEAL:
                self.car_odom_pubs[car_name] = rospy.Publisher(
                    f'/cars/{car_name}/odom', Odometry, queue_size=1)

        # Node data
        self.cmd_lock = Lock()
        self.reset_lock = Lock()
        self.last_time = None

        # Publishers
        self.status_pub = rospy.Publisher(
            'match_status', MatchStatus, queue_size=1)

        # Services
        rospy.Service('sim_reset', Empty, self.reset_cb)
        rospy.Service('sim_create_car', CreateCar, self.create_car_cb)
        rospy.Service('sim_delete_car', DeleteCar, self.delete_car_cb)

        while not rospy.is_shutdown():
            self.loop_once()
            try:
                rate.sleep()
            except rospy.ROSInterruptException:
                pass

    def get_rand_num_from_range(self, v1, v2):
        minVal = min(v1, v2)
        maxval = max(v1, v2)
        return random.randint(minVal, maxval)

    """
    generates the upper and lower spawn bounds
    fw1: first width bound
    fw2: second width bound
    fl1: first length bound
    fl2: second length bound
    returns a tupple where entry 2= random width between fw1/fw2 and entry 1= random length between fl1/2
    """

    def get_rand_spawn_bounds(self, fw1, fw2, fl1, fl2):
        lowerFw = min(fw1, fw2);
        lowerFl = min(fl1, fl2);

        upperFw = max(fw1, fw2)
        upperFl = max(fl1, fl2)

        return self.get_rand_num_from_range(lowerFw, upperFw), self.get_rand_num_from_range(lowerFl, upperFl)

    """
    overview: Checks whether you ahvea valid pybullet url for information
    if not, wait for the file to build in .5 seconds
    """

    def check_urdf(self, param):
        """Validates that a URDF exists, then returns path"""
        if param is None:
            rospy.signal_shutdown('no urdf path set for "{}"'.format(param))

        i = 0
        while not os.path.isfile(param) and i < 5:
            rospy.sleep(0.1)  # Wait for xacro build
            i += 1

        if not os.path.isfile(param):
            rospy.signal_shutdown(
                'no urdf file exists at path {}'.format(param))

    # TODO: how do effort_cb and cmd_cb interact?
    """
    Overrides the cmd_cb: calls the car command with the throttle and steering
    TODO: during which state is it called with
    """

    def effort_cb(self, effort_msg, car_id):
        """Sets a car's effort (overwrites commands)"""
        self.cmd_lock.acquire()
        self.sim.set_car_command(car_id,
                                 (effort_msg.throttle, effort_msg.steering))
        self.cmd_lock.release()

    """
    Overrides the effirt_cd: calls the car
    Command with the velocity and the curvature
    """

    def cmd_cb(self, cmd_msg, car_id):
        """Sets a car's command (overwrites efforts)"""
        self.cmd_lock.acquire()
        self.sim.set_car_command(car_id,
                                 (cmd_msg.velocity, cmd_msg.curvature))
        self.cmd_lock.release()

    """
    Add new car to the simulator
    Checks if resetting to random position: 
    - if not, set it to default
    - if so, will be reset later in the sim.create_car function
    
    Get the car id,
    Subscribe:
    - effort cb: args: car_id
    - command cb: args: car_id
    If realistic mode:
    - Publish to the pose sync early (with car id)
    - Publish to the odometry truth (with car id)
    If ideal mode:
    - Publish to the odometry (with car id)
    """

    def create_car_cb(self, req):
        """Adds a new car to the simulator"""
        self.reset_lock.acquire()
        if req.name in self.car_ids:
            return CreateCarResponse(False)

        init_pose = None
        if req.reset_to_random_pose is False:
            init_pose = {
                "pos": [req.init_pos.x,
                        req.init_pos.y,
                        req.init_pos.z],
                "orient": [0.0, 0.0, req.init_yaw],
            }

        self.car_ids[req.name] = self.sim.create_car(
            'car', init_pose, noise=self.car_noise, props=self.car_properties)

        car_id = self.car_ids[req.name]
        self.car_effort_subs[req.name] = rospy.Subscriber(
            f'/cars/{req.name}/effort', ControlEffort,
            self.effort_cb, callback_args=car_id)
        self.car_cmd_subs[req.name] = rospy.Subscriber(
            f'/cars/{req.name}/command', ControlCommand,
            self.cmd_cb, callback_args=car_id)

        if self.mode == SimulatorMode.REALISTIC:
            self.car_pose_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/pose_sync_early',
                PoseWithCovarianceStamped, queue_size=1)
            self.car_odom_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/odom_truth', Odometry, queue_size=1)
        elif self.mode == SimulatorMode.IDEAL:
            self.car_odom_pubs[req.name] = rospy.Publisher(
                f'/cars/{req.name}/odom', Odometry, queue_size=1)

        self.reset_lock.release()
        return CreateCarResponse(True)

    """
    Remove car from the simulator
    Delete the effort,cmd subs (check if they exist first)
    delete the odom, pose publishers (check if they exist first)
    Delete cars body from pybullet by called sim.delete_car
    """

    def delete_car_cb(self, req):
        """Removes a car from the simulator"""
        self.reset_lock.acquire()
        if req.name not in self.car_ids:
            return DeleteCarResponse(False)

        # Delete all related pubs and subs
        if req.name in self.car_effort_subs:
            self.car_effort_subs[req.name].unregister()
            del self.car_effort_subs[req.name]
        if req.name in self.car_cmd_subs:
            self.car_cmd_subs[req.name].unregister()
            del self.car_cmd_subs[req.name]
        if req.name in self.car_odom_pubs:
            self.car_odom_pubs[req.name].unregister()
            del self.car_odom_pubs[req.name]
        if req.name in self.car_pose_pubs:
            self.car_pose_pubs[req.name].unregister()
            del self.car_pose_pubs[req.name]

        # Delete the car's body from pybullet
        res = self.sim.delete_car(self.car_ids[req.name])
        del self.car_ids[req.name]

        self.reset_lock.release()
        return DeleteCarResponse(res)

    # TODO: what is the car_cmd? (velocity and angle maybe?)
    """
    Resets the simulator
    Reset the sim.py for each car
    Rest the time
    Reset the car_cmd
    """

    def reset_cb(self, _):
        """Resets simulator"""
        self.reset_lock.acquire()
        self.sim.reset(self.car_properties, self.)
        self.car_cmd = (0.0, 0.0)
        self.last_time = None
        self.reset_lock.release()
        return EmptyResponse()

    """
    Pause the time
    Step the simulation once step
    Update the match status: if either team scored, show the winner, if not, continue the match
    
    If the simulation mode is realistic:
    - Write the ball positing and orientation variables (pub)
    - Write each cars position and orientation variables (pub)
    For all modes (ideal and realistic):
    Move the ball forward: get its position, and publish it (via Odometry() func)
    For each car, move it forward, get its position and publish it (via Odometry() func)
    Resume the time
    """

    def loop_once(self):
        """Main loop"""
        self.reset_lock.acquire()
        now = rospy.Time.now()
        if self.last_time is not None and self.last_time != now:
            # Iterate sim one step
            delta_t = (now - self.last_time).to_sec()
            self.sim.step(delta_t)

            # Publish game status
            status = MatchStatus()
            if self.sim.scored:
                if self.sim.winner == "A":
                    status.status = MatchStatus.VICTORY_TEAM_A
                elif self.sim.winner == "B":
                    status.status = MatchStatus.VICTORY_TEAM_B
            else:
                status.status = MatchStatus.ONGOING
            self.status_pub.publish(status)

            # Publish pose and odometry data
            if self.mode == SimulatorMode.REALISTIC:
                ball_msg = PoseWithCovarianceStamped()
                ball_msg.header.stamp = now
                ball_msg.header.frame_id = self.frame_id
                ball_pos, ball_quat = self.sim.get_ball_pose(add_noise=True)
                ball_msg.pose.pose.position.x = ball_pos[0]
                ball_msg.pose.pose.position.y = ball_pos[1]
                ball_msg.pose.pose.position.z = ball_pos[2]
                ball_msg.pose.pose.orientation.x = ball_quat[0]
                ball_msg.pose.pose.orientation.y = ball_quat[1]
                ball_msg.pose.pose.orientation.z = ball_quat[2]
                ball_msg.pose.pose.orientation.w = ball_quat[3]
                self.ball_pose_pub.publish(ball_msg)

                for car_name in self.car_ids:
                    car_msg = PoseWithCovarianceStamped()
                    car_msg.header.stamp = now
                    car_msg.header.frame_id = self.frame_id
                    car_pos, car_quat = self.sim.get_car_pose(
                        self.car_ids[car_name], add_noise=True)
                    car_msg.pose.pose.position.x = car_pos[0]
                    car_msg.pose.pose.position.y = car_pos[1]
                    car_msg.pose.pose.position.z = car_pos[2]
                    car_msg.pose.pose.orientation.x = car_quat[0]
                    car_msg.pose.pose.orientation.y = car_quat[1]
                    car_msg.pose.pose.orientation.z = car_quat[2]
                    car_msg.pose.pose.orientation.w = car_quat[3]
                    self.car_pose_pubs[car_name].publish(car_msg)
            # TODO: why not in an else block: publish data twice no?
            ball_msg = Odometry()
            ball_msg.header.stamp = now
            ball_msg.header.frame_id = self.frame_id
            ball_pos, ball_quat = self.sim.get_ball_pose()
            ball_msg.pose.pose.position.x = ball_pos[0]
            ball_msg.pose.pose.position.y = ball_pos[1]
            ball_msg.pose.pose.position.z = ball_pos[2]
            ball_msg.pose.pose.orientation.x = ball_quat[0]
            ball_msg.pose.pose.orientation.y = ball_quat[1]
            ball_msg.pose.pose.orientation.z = ball_quat[2]
            ball_msg.pose.pose.orientation.w = ball_quat[3]
            ball_linear, ball_angular = self.sim.get_ball_velocity()
            ball_msg.twist.twist.linear.x = ball_linear[0]
            ball_msg.twist.twist.linear.y = ball_linear[1]
            ball_msg.twist.twist.linear.z = ball_linear[2]
            ball_msg.twist.twist.angular.x = ball_angular[0]
            ball_msg.twist.twist.angular.y = ball_angular[1]
            ball_msg.twist.twist.angular.z = ball_angular[2]
            self.ball_odom_pub.publish(ball_msg)

            for car_name in self.car_ids:
                car_msg = Odometry()
                car_msg.header.stamp = now
                car_msg.header.frame_id = self.frame_id
                car_pos, car_quat = self.sim.get_car_pose(
                    self.car_ids[car_name])
                car_msg.pose.pose.position.x = car_pos[0]
                car_msg.pose.pose.position.y = car_pos[1]
                car_msg.pose.pose.position.z = car_pos[2]
                car_msg.pose.pose.orientation.x = car_quat[0]
                car_msg.pose.pose.orientation.y = car_quat[1]
                car_msg.pose.pose.orientation.z = car_quat[2]
                car_msg.pose.pose.orientation.w = car_quat[3]
                car_linear, car_angular = self.sim.get_car_velocity(
                    self.car_ids[car_name])
                car_msg.twist.twist.linear.x = car_linear[0]
                car_msg.twist.twist.linear.y = car_linear[1]
                car_msg.twist.twist.linear.z = car_linear[2]
                car_msg.twist.twist.angular.x = car_angular[0]
                car_msg.twist.twist.angular.y = car_angular[1]
                car_msg.twist.twist.angular.z = car_angular[2]
                self.car_odom_pubs[car_name].publish(car_msg)

        self.last_time = now
        self.reset_lock.release()

    def generate_max_speed(self):
        # TODO: need to update these paramters in the yaml
        """
        randomize the car max speed
        if randomize, generate an int between the max speeds
        if not, use the first paramter
        """
        rand_max_speed = rospy.get_param("/cars/rand_max_speed")
        if rand_max_speed:
            max_speed_1 = rospy.get_param('/cars/throttle/max_speed_1')
            max_speed_2 = rospy.get_param('/cars/throttle/max_speed_2')
            return self.get_rand_num_from_range(max_speed_1, max_speed_2)
        else:
            return rospy.get_param('/cars/throttle/max_speed_1')

    def generate_steering_throw(self):
        """
                randomize the car steering throw
                if randomize, generate an int between the steering throws
                if not, use the first paramter
                """
        rand_steering_throw = rospy.get_param("/cars/rand_steering_throw")
        if rand_steering_throw:
            max_steering_throw_1 = rospy.get_param('/cars/throttle/max_steering_throw_1')
            max_steering_throw_2 = rospy.get_param('/cars/throttle/max_steering_throw_2')
            return self.get_rand_num_from_range(max_steering_throw_1, max_steering_throw_2)
        else:
            return rospy.get_param('/cars/throttle/max_steering_throw_2')


"""the main function: call the simulator to init the loop and create objects"""
if __name__ == "__main__":
    Simulator()
