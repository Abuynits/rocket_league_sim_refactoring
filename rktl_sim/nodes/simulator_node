#!/usr/bin/env python3
"""Node to run the simulator with ROS bindings.
License:
  BSD 3-Clause License
  Copyright (c) 2020, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.

TODO:
- Scale to support multiple vehicles
- Add offset for walls
"""

# 3rd party modules
from rktl_msgs.msg import ControlEffort
from nav_msgs.msg import Odometry
import os
import rospy
from std_srvs.srv import Empty, EmptyResponse
from threading import Lock

# Local library
import simulator
from rktl_msgs.msg import MatchStatus

class SimulatorROS(object):
    """ROS wrapper for the simulator."""

    def __init__(self):
        rospy.init_node('simulator')

        # Collecting global parameters
        fw = rospy.get_param('/field/width')
        fl = rospy.get_param('/field/length')
        wt = rospy.get_param('/field/wall_thickness')
        gw = rospy.get_param('/field/goal/width')

        # Collecting private parameters
        render_enabled = rospy.get_param('~render', False)
        rate = rospy.Rate(rospy.get_param('~rate', 30))
        self.frame_id = rospy.get_param('~frame_id', 'map')
        self.timeout = rospy.get_param('~timeout', 10)
        car_init = rospy.get_param('~init/car', None)
        ball_init = rospy.get_param('~init/ball', None)
        speed_init = rospy.get_param('~init/speed', 0.0)
        spawn_height = rospy.get_param('~spawn_height', 0.06)

        field_setup = {}

        if car_init is not None:
            field_setup['car'] = car_init

        if ball_init is not None:
            field_setup['ball'] = ball_init

        field_setup["goalA"] = [(fl/2.) + (wt/2.), 0, spawn_height]
        field_setup["goalB"] = [(-fl/2.) - (wt/2.), 0, spawn_height]
        field_setup["rsidewall"] = [0, (fw/2) + (wt/2.), spawn_height]
        field_setup["lsidewall"] = [0, (-fw/2) - (wt/2.), spawn_height]

        bww = (fw-gw)/2
        offset = (gw+bww)/2
        field_setup["flbackwall"] = [(fl/2) + (wt/2.), -offset, spawn_height]
        field_setup["frbackwall"] = [(fl/2) + (wt/2.), offset, spawn_height]
        field_setup["blbackwall"] = [(-fl/2) - (wt/2.), -offset, spawn_height]
        field_setup["brbackwall"] = [(-fl/2) - (wt/2.), offset, spawn_height]

        # Setup bounds for spawning car and ball
        spawn_bounds = [[-(fl/2) + (2 * wt), (fl/2) - (2 * wt)],
                        [-(fw/2) + (2 * wt), (fw/2) - (2 * wt)],
                        [spawn_height, spawn_height]]

        urdf_paths = {}
        urdf_paths["ball"] = rospy.get_param('~urdf/ball')
        self.check_urdf(urdf_paths["ball"])
        urdf_paths["car"] = rospy.get_param('~urdf/car')
        self.check_urdf(urdf_paths["car"])
        urdf_paths["goal"] = rospy.get_param('~urdf/goal')
        self.check_urdf(urdf_paths["goal"])
        urdf_paths["sidewall"] = rospy.get_param('~urdf/sidewall')
        self.check_urdf(urdf_paths["sidewall"])
        urdf_paths["backwall"] = rospy.get_param('~urdf/backwall')
        self.check_urdf(urdf_paths["backwall"])
        urdf_paths["plane"] = rospy.get_param('~urdf/plane')
        self.check_urdf(urdf_paths["plane"])

        car_properties = {}
        car_properties['length'] = rospy.get_param('/cars/length')
        car_properties['max_speed'] = rospy.get_param('/cars/throttle/max_speed')
        car_properties['throttle_tau'] = rospy.get_param('/cars/throttle/tau')
        car_properties['steering_throw'] = rospy.get_param('/cars/steering/max_throw')
        car_properties['steering_rate'] = rospy.get_param('/cars/steering/rate')

        # Creating physics simulator
        self.sim = simulator.Sim(
            urdf_paths, field_setup, spawn_bounds, speed_init, render_enabled, car_properties)

        self.cmd_lock = Lock()
        self.reset_lock = Lock()
        self.throttle_cmd = 0.
        self.steering_cmd = 0.
        self.last_time = None

        # Publishers
        self.ball_pub = rospy.Publisher('ball/odom',
                                        Odometry, queue_size=1)
        self.car_pub = rospy.Publisher('cars/car0/odom', Odometry, queue_size=1)
        self.status_pub = rospy.Publisher(
            'match_status', MatchStatus, queue_size=1)

        # Subscribers
        rospy.Subscriber('cars/car0/effort', ControlEffort, self.effort_cb)

        # Services
        rospy.Service('sim_reset', Empty, self.reset_cb)

        while not rospy.is_shutdown():
            self.loop_once()
            try:
                rate.sleep()
            except rospy.ROSInterruptException:
                pass

    def check_urdf(self, param):
        """Validates that URDF exists, then returns path."""
        if param is None:
            rospy.signal_shutdown('no urdf path set for "{}"'.format(param))

        if not os.path.isfile(param):
            rospy.signal_shutdown(
                'no urdf file exists at path {}'.format(param))

    def effort_cb(self, effort_msg):
        self.cmd_lock.acquire()
        self.throttle_cmd = effort_msg.throttle
        self.steering_cmd = effort_msg.steering
        self.cmd_lock.release()

    def reset_cb(self, _):
        """Resets simulator."""
        self.reset_lock.acquire()
        self.sim.reset()
        self.throttle_cmd = 0.
        self.steering_cmd = 0.
        self.last_time = None
        self.reset_lock.release()
        return EmptyResponse()

    def loop_once(self):
        """Main loop."""
        self.reset_lock.acquire()
        now = rospy.Time.now()
        if self.last_time is not None and self.last_time != now:
            # Iterate sim one step
            delta_t = (now - self.last_time).to_sec()

            status = MatchStatus()
            if self.sim.scored:
                if self.sim.winner == "A":
                    status.status = MatchStatus.VICTORY_TEAM_A
                elif self.sim.winner == "B":
                    status.status = MatchStatus.VICTORY_TEAM_B
            else:
                status.status = MatchStatus.ONGOING
            self.status_pub.publish(status)

            self.sim.step(self.throttle_cmd, self.steering_cmd, delta_t)

            # Publish ball odometry
            ball_msg = Odometry()
            ball_msg.header.stamp = now
            ball_msg.header.frame_id = self.frame_id
            ball_pos, ball_quat = self.sim.getBallPose()
            ball_msg.pose.pose.position.x = ball_pos[0]
            ball_msg.pose.pose.position.y = ball_pos[1]
            ball_msg.pose.pose.position.z = ball_pos[2]
            ball_msg.pose.pose.orientation.x = ball_quat[0]
            ball_msg.pose.pose.orientation.y = ball_quat[1]
            ball_msg.pose.pose.orientation.z = ball_quat[2]
            ball_msg.pose.pose.orientation.w = ball_quat[3]
            ball_linear, ball_angular = self.sim.getBallVelocity()
            ball_msg.twist.twist.linear.x = ball_linear[0]
            ball_msg.twist.twist.linear.y = ball_linear[1]
            ball_msg.twist.twist.linear.z = ball_linear[2]
            ball_msg.twist.twist.angular.x = ball_angular[0]
            ball_msg.twist.twist.angular.y = ball_angular[1]
            ball_msg.twist.twist.angular.z = ball_angular[2]
            self.ball_pub.publish(ball_msg)

            # Publish bot odometry
            car_msg = Odometry()
            car_msg.header.stamp = now
            car_msg.header.frame_id = self.frame_id
            car_pos, car_quat = self.sim.getCarPose()
            car_msg.pose.pose.position.x = car_pos[0]
            car_msg.pose.pose.position.y = car_pos[1]
            car_msg.pose.pose.position.z = car_pos[2]
            car_msg.pose.pose.orientation.x = car_quat[0]
            car_msg.pose.pose.orientation.y = car_quat[1]
            car_msg.pose.pose.orientation.z = car_quat[2]
            car_msg.pose.pose.orientation.w = car_quat[3]
            car_linear, car_angular = self.sim.getCarVelocity()
            car_msg.twist.twist.linear.x = car_linear[0]
            car_msg.twist.twist.linear.y = car_linear[1]
            car_msg.twist.twist.linear.z = car_linear[2]
            car_msg.twist.twist.angular.x = car_angular[0]
            car_msg.twist.twist.angular.y = car_angular[1]
            car_msg.twist.twist.angular.z = car_angular[2]
            self.car_pub.publish(car_msg)

        self.last_time = now
        self.reset_lock.release()

if __name__ == "__main__":
    SimulatorROS()
