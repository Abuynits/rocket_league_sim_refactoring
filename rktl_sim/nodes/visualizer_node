#!/usr/bin/env python3
"""Node to run the visualizer with ROS bindings.
License:
  BSD 3-Clause License
  Copyright (c) 2020, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.

TODO:
- Scale to support multiple cars
"""

# 3rd party modules
from std_msgs.msg import Float32
import math
from nav_msgs.msg import Odometry
import os
import rospy
from std_srvs.srv import Empty, EmptyResponse
from tf.transformations import euler_from_quaternion
from threading import Lock
import numpy as np

# Local library
import visualizer
from geometry_msgs.msg import Twist, PoseWithCovarianceStamped
from rktl_msgs.msg import Target, Path, MultiBezierPath, PathError, Waypoint, MatchStatus
from rktl_planner import BezierPath


class VisualizerROS(object):
    """ROS wrapper for the visualizer."""

    def __init__(self):
        rospy.init_node("visualizer")

        # Collecting global parameters
        field_width = rospy.get_param("FIELD_WIDTH")
        field_length = rospy.get_param("FIELD_LENGTH")
        goal_width = rospy.get_param("GOAL_WIDTH")
        wall_thickness = rospy.get_param("WALL_THICKNESS")
        ball_radius = rospy.get_param("BALL_RADIUS")
        car_width = rospy.get_param("CAR_WIDTH")
        car_length = rospy.get_param("CAR_LENGTH")

        # Creating pygame render
        self.window = visualizer.Window(
            field_width, field_length, wall_thickness)

        # Collecting private parameters
        self.frame_id = rospy.get_param("~FRAME_ID", "map")
        self.timeout = rospy.get_param("~TIMEOUT", 10)
        rate = rospy.Rate(rospy.get_param("~RATE", 20))

        # Setup field assets
        self.window.createAsset(
            1, wall_thickness, field_length, color=(0, 0, 0),
            initPos=(0., (field_width + (wall_thickness / 2.)) / 2.))
        self.window.createAsset(
            2, wall_thickness, field_length, color=(0, 0, 0),
            initPos=(0., -(field_width + (wall_thickness / 2.)) / 2.))

        backwall_width = (field_width - goal_width) / 2.
        self.window.createAsset(
            3, backwall_width, wall_thickness, color=(0, 0, 0),
            initPos=((field_length + (wall_thickness / 2.)) / 2., (field_width / 2.) - (backwall_width / 2.)))
        self.window.createAsset(
            4, backwall_width, wall_thickness, color=(0, 0, 0),
            initPos=((field_length + (wall_thickness / 2.)) / 2., -(field_width / 2.) + (backwall_width / 2.)))
        self.window.createAsset(
            5, backwall_width, wall_thickness, color=(0, 0, 0),
            initPos=(-(field_length + (wall_thickness / 2.)) / 2., (field_width / 2.) - (backwall_width / 2.)))
        self.window.createAsset(
            6, backwall_width, wall_thickness, color=(0, 0, 0),
            initPos=(-(field_length + (wall_thickness / 2.)) / 2., -(field_width / 2.) + (backwall_width / 2.)))

        car_img_path = rospy.get_param("~CAR_IMG_PATH", None)
        if car_img_path is not None:
            self.car_id = 7
            self.window.createAsset(
                self.car_id, car_width, car_length, imgPath=car_img_path)

        ball_img_path = rospy.get_param("~BALL_IMG_PATH", None)
        if ball_img_path is not None:
            self.ball_id = 8
            self.window.createAsset(
                self.ball_id, ball_radius * 2, ball_radius * 2, imgPath=ball_img_path)

        # TODO: Verify wall thickness and goal positions
        goal_img_path = rospy.get_param("~GOAL_IMG_PATH", None)
        if goal_img_path is not None:
            # Top Goal:
            self.goal1_id = 9
            self.window.createAsset(
                self.goal1_id, goal_width, wall_thickness, imgPath=goal_img_path
            )
            self.window.updateAssetPos(
                self.goal1_id, (field_length / 2) + (wall_thickness / 4), 0)
            # Bottom Goal:
            self.goal2_id = 10
            self.window.createAsset(
                self.goal2_id, goal_width, wall_thickness, imgPath=goal_img_path
            )
            self.window.updateAssetPos(
                self.goal2_id, -((field_length / 2) + (wall_thickness / 4)), 0)
            self.window.updateAssetAngle(self.goal2_id, 180)

        self.lines_id = 11
        self.window.createAsset(self.lines_id, 0, 0, color=(255, 0, 0), lines=True)

        self.circle_id = 12
        self.window.createAsset(self.circle_id, 0, 0, circle=True, color=(255,0,0), radius=0.25)

        self.lock = Lock()
        self.last_time = None
        self.path = None

        # Subscribers
        rospy.Subscriber("ball/odom", Odometry, self.ball_odom_cb)
        rospy.Subscriber("car0/odom", Odometry, self.car_odom_cb)
        rospy.Subscriber("car0/path", Path, self.path_arr_cb)
        rospy.Subscriber(
            "car0/lookahead_dist", Float32, self.lookahead_cb
        )
        rospy.Subscriber("bezier_path", MultiBezierPath, self.bezier_path_cb)

        while not rospy.is_shutdown():
            self.window.show()
            try:
                rate.sleep()
            except rospy.ROSInterruptException:
                pass

    def car_odom_cb(self, odom_msg):
        x = odom_msg.pose.pose.position.x
        y = odom_msg.pose.pose.position.y
        orient = odom_msg.pose.pose.orientation
        quat = [orient.x, orient.y, orient.z, orient.w]
        heading = euler_from_quaternion(quat)[2]
        heading = heading * 180. / math.pi
        self.window.updateAssetPos(self.car_id, x, y)
        self.window.updateAssetAngle(self.car_id, heading)
        self.window.updateAssetPos(self.circle_id, x, y)

    def ball_odom_cb(self, odom_msg):
        x = odom_msg.pose.pose.position.x
        y = odom_msg.pose.pose.position.y
        self.window.updateAssetPos(self.ball_id, x, y)

    def path_arr_cb(self, path_arr_msg):
        """Callback for path array messages."""
        self.window.resetAssetLines(self.lines_id)
        self.path = path_arr_msg.waypoint
        for point in self.path:
            x = point.pose.position.x
            y = point.pose.position.y
            self.window.updateAssetPos(self.lines_id, x, y)
    
    def bezier_path_cb(self, msg: MultiBezierPath):
        """Callback for bezier path messages."""
        self.window.resetAssetLines(self.lines_id)
        paths = [BezierPath(x) for x in msg.paths]
        for path in paths:
            #for point in path.bezier_curve.control_points:
            #    self.window.updateAssetPos(self.lines_id, point.x, point.y)
            sec = path.duration.to_sec()
            for t in np.linspace(0., sec, int(50 * sec + 0.5)):
                point = path.at(t)
                self.window.updateAssetPos(self.lines_id, point.x, point.y)

    def lookahead_cb(self, msg: Float32):
        """Callback for lookahead_pnt messages."""
        self.window.updateAssetRadius(self.circle_id, msg.data)

if __name__ == "__main__":
    VisualizerROS()