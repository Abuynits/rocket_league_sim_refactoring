#!/usr/bin/env python3
"""Real-time evaluation of the agent trained for the Rocket League project.
License:
  BSD 3-Clause License
  Copyright (c) 2022, Autonomous Robotics Club of Purdue (Purdue ARC)
  All rights reserved.
"""

from rktl_autonomy import RocketLeagueInterface
from stable_baselines3 import PPO
from os.path import expanduser
import rospy, math, numpy

# create interface (and init ROS)
env = RocketLeagueInterface(eval=True)

# pull some parameters
FIELD_WIDTH = rospy.get_param('/field/width')
FIELD_LENGTH = rospy.get_param('/field/length')

# load the models
weights = expanduser(rospy.get_param('~scoring_weights'))
scoring_model = PPO.load(weights)

weights = expanduser(rospy.get_param('~chasing_weights'))
chasing_model = PPO.load(weights)

# default is to chase
chasing = True

# evaluate in real-time
obs = env.reset()
while True:
    # obs is a np array with following indices:
    #   x, y, theta, v, omega (car)
    #   x, y, vx, vy (ball)
    x_car, y_car, theta_car, v_car, omega_car, x_ball, y_ball, vx_ball, vy_ball = numpy.split(obs, 9)

    ball_dist = math.sqrt(pow(x_car-x_ball, 2) + pow(y_car-y_ball, 2))
    if ball_dist < 1.5:
        # use the regular model to win
        chasing = False
    elif ball_dist > 3.0:
        # use the chasing model to make noisy
        chasing = True

    # additional cases can go here
    #   ex: random chance
    #   ex: ball position

    if chasing:
        print("using chasing weights")
        action, __ = chasing_model.predict(obs)
    else:
        print("using scoring weights")
        action, __ = scoring_model.predict(obs)

    # send to network, get new obs
    try:
        obs, __, __, __ = env.step(action)
    except rospy.ROSInterruptException:
        exit()
